<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-05-05 lun. 17:37 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Write yourself a Git!</title>
<meta name="author" content="[[mailto:thibault@thb.lt][Thibault Polge]]" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="src/readtheorg_theme/js/readtheorg.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Write yourself a Git!</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#intro">1. Introduction</a></li>
<li><a href="#getting-started">2. Getting started</a></li>
<li><a href="#init">3. Creating repositories: init</a>
<ul>
<li><a href="#GitRepository">3.1. The Repository object</a></li>
<li><a href="#cmd-init">3.2. The init command</a></li>
<li><a href="#org2a7c67b">3.3. The repo_find() function</a></li>
</ul>
</li>
<li><a href="#objects">4. Reading and writing objects: hash-object and cat-file</a>
<ul>
<li><a href="#objects-intro">4.1. What are objects?</a></li>
<li><a href="#org6464558">4.2. A generic object object</a></li>
<li><a href="#object_read">4.3. Reading objects</a></li>
<li><a href="#org54f0022">4.4. Writing objects</a></li>
<li><a href="#orgfe7c2d7">4.5. Working with blobs</a></li>
<li><a href="#cmd-cat-file">4.6. The cat-file command</a></li>
<li><a href="#cmd-hash-object">4.7. The hash-object command</a></li>
<li><a href="#packfiles">4.8. Aside: what about packfiles?</a></li>
</ul>
</li>
<li><a href="#orgd9ed94e">5. Reading commit history: log</a>
<ul>
<li><a href="#orgb06b20e">5.1. Parsing commits</a></li>
<li><a href="#org5897046">5.2. The Commit object</a></li>
<li><a href="#cmd-log">5.3. The log command</a></li>
<li><a href="#commit-anatomy">5.4. Anatomy of a commit</a></li>
</ul>
</li>
<li><a href="#checkout">6. Reading commit data: checkout</a>
<ul>
<li><a href="#orgff23f86">6.1. What&rsquo;s in a tree?</a></li>
<li><a href="#orgdc9fa8c">6.2. Parsing trees</a></li>
<li><a href="#cmd-ls-tree">6.3. Showing trees: ls-tree</a></li>
<li><a href="#cmd-checkout">6.4. The checkout command</a></li>
</ul>
</li>
<li><a href="#org6d10996">7. Refs, tags and branches</a>
<ul>
<li><a href="#cmd-show-ref">7.1. What a ref is, and the show-ref command</a></li>
<li><a href="#tags">7.2. Tags as references</a></li>
<li><a href="#GitTag">7.3. Lightweight tags and tag objects, and parsing the latter</a></li>
<li><a href="#cmd-tag">7.4. The tag command</a></li>
<li><a href="#branches">7.5. What&rsquo;s a branch?</a></li>
<li><a href="#object_find">7.6. Referring to objects: the <code>object_find</code> function</a>
<ul>
<li><a href="#org753766b">7.6.1. Resolving names</a></li>
<li><a href="#cmd-rev-parse">7.6.2. The rev-parse command</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#staging-area">8. Working with the staging area and the index file</a>
<ul>
<li><a href="#staging-intro">8.1. What&rsquo;s the index file?</a></li>
<li><a href="#index_read">8.2. Parsing the index</a></li>
<li><a href="#cmd-ls-files">8.3. The ls-files command</a></li>
<li><a href="#cmd-check-ignore">8.4. A detour: the check-ignore command</a></li>
<li><a href="#cmd-status">8.5. The status command</a>
<ul>
<li><a href="#org6fc9507">8.5.1. Finding the active branch</a></li>
<li><a href="#org45002f7">8.5.2. Finding changes between HEAD and index</a></li>
<li><a href="#org8b48b89">8.5.3. Finding changes between index and worktree</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#committing">9. Staging area and index, part 2: staging and committing</a>
<ul>
<li><a href="#index_write">9.1. Writing the index</a></li>
<li><a href="#cmd-rm">9.2. The rm command</a></li>
<li><a href="#cmd-add">9.3. The add command</a></li>
<li><a href="#cmd-commit">9.4. The commit command</a></li>
</ul>
</li>
<li><a href="#org6d635aa">10. Final words</a>
<ul>
<li><a href="#feedback">10.1. Comments, feedback and issues</a></li>
<li><a href="#org4973c11">10.2. License</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-intro" class="outline-2">
<h2 id="intro"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-intro">
<div class="note" id="org7ebc872">
<p>
Recent changes (January 2025):
</p>

<ul class="org-ul">
<li><code>OrderedDict</code> have been replaced by regular dicts.</li>
<li>Most string formatting have been replaced with f-strings.</li>
<li>Multible bugs fixed in <code>tag_create</code>.</li>
</ul>

</div>

<p>
This article is an attempt at explaining the <a href="https://git-scm.com/">Git version control
system</a> from the bottom up, that is, starting at the most fundamental
level moving up from there.  This does not sound too easy, and has
been attempted multiple times with questionable success.  But there&rsquo;s
an easy way: all it takes to understand Git internals is to
reimplement Git from scratch.
</p>

<p>
No, don&rsquo;t run.
</p>

<p>
It&rsquo;s not a joke, and it&rsquo;s really not complicated: if you read this
article top to bottom and write the code (or just <a href="./wyag.zip">download it</a> as a ZIP
&#x2014; but you should write the code yourself, really), you&rsquo;ll end up
with a program, called <code>wyag</code>, that will implement all the fundamental
features of git: <code>init</code>, <code>add</code>, <code>rm</code>, <code>status</code>, <code>commit</code>, <code>log</code>&#x2026; in
a way that is perfectly compatible with <code>git</code> itself &#x2014; compatible
enough that the commit finally adding the section on commits was
<a href="https://github.com/thblt/write-yourself-a-git/commit/ed26daffb400b2be5f30e044c3237d220226d867">created by wyag itself, not git</a>.  And all that in exactly 978
lines of very simple Python code.
</p>

<p>
But isn&rsquo;t Git too complex for that?  That Git is complex is, in my
opinion, a misconception.  Git is a large program, with a lot of
features, that&rsquo;s true.  But the core of that program is actually
extremely simple, and its apparent complexity stems first from the
fact it&rsquo;s often deeply counterintuitive (and <a href="https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">Git is a burrito</a> blog
posts probably don&rsquo;t help).  But maybe what makes Git the most
confusing is the extreme simplicity <i>and</i> power of its core model.  The
combination of core simplicity and powerful applications often makes
thing really hard to grasp, because of the mental jump required to
derive the variety of applications from the essential simplicity of
the fundamental abstraction (monads, anyone?)
</p>

<p>
Implementing Git will expose its fundamentals in all their naked
glory.
</p>

<p>
<b>What to expect?</b>  This article will implement and explain in great
details (if something is not clear, please <a href="#feedback">report it</a>!) a very
simplified version of Git core commands.  I will keep the code simple
and to the point, so <code>wyag</code> won&rsquo;t come anywhere near the power of the
real git command-line &#x2014; but what&rsquo;s missing will be obvious, and
trivial to implement by anyone who wants to give it a try.  “Upgrading
wyag to a full-featured git library and CLI is left as an exercise to
the reader”, as they say.
</p>

<p>
More precisely, we&rsquo;ll implement:
</p>

<ul class="org-ul">
<li><code>add</code> (<a href="#cmd-add">wyag source</a>) <a href="https://git-scm.com/docs/git-add">git man page</a></li>
<li><code>cat-file</code> (<a href="#cmd-cat-file">wyag source</a>) <a href="https://git-scm.com/docs/git-cat-file">git man page</a></li>
<li><code>check-ignore</code> (<a href="#cmd-check-ignore">wyag source</a>) <a href="https://git-scm.com/docs/git-check-ignore">git man page</a></li>
<li><code>checkout</code> (<a href="#cmd-checkout">wyag source</a>) <a href="https://git-scm.com/docs/git-checkout">git man page</a></li>
<li><code>commit</code> (<a href="#cmd-commit">wyag source</a>) <a href="https://git-scm.com/docs/git-commit">git man page</a></li>
<li><code>hash-object</code> (<a href="#cmd-hash-object">wyag source</a>) <a href="https://git-scm.com/docs/git-hash-object">git man page</a></li>
<li><code>init</code> (<a href="#cmd-init">wyag source</a>) <a href="https://git-scm.com/docs/git-init">git man page</a></li>
<li><code>log</code> (<a href="#cmd-log">wyag source</a>) <a href="https://git-scm.com/docs/git-log">git man page</a></li>
<li><code>ls-files</code> (<a href="#cmd-ls-files">wyag source</a>) <a href="https://git-scm.com/docs/git-ls-files">git man page</a></li>
<li><code>ls-tree</code> (<a href="#cmd-ls-tree">wyag source</a>) <a href="https://git-scm.com/docs/git-ls-tree">git man page</a></li>
<li><code>rev-parse</code> (<a href="#cmd-rev-parse">wyag source</a>) <a href="https://git-scm.com/docs/git-rev-parse">git man page</a></li>
<li><code>rm</code> (<a href="#cmd-rm">wyag source</a>) <a href="https://git-scm.com/docs/git-rm">git man page</a></li>
<li><code>show-ref</code> (<a href="#cmd-show-ref">wyag source</a>) <a href="https://git-scm.com/docs/git-show-ref">git man page</a></li>
<li><code>status</code> (<a href="#cmd-status">wyag source</a>) <a href="https://git-scm.com/docs/git-status">git man page</a></li>
<li><code>tag</code> (<a href="#cmd-tag">wyag source</a>) <a href="https://git-scm.com/docs/git-tag">git man page</a></li>
</ul>

<p>
You&rsquo;re not going to need to know much to follow this article: just
some basic Git (obviously), some basic Python, some basic shell.
</p>

<ul class="org-ul">
<li>First, I&rsquo;m only going to assume some level of familiarity with the
most basic <b>git commands</b> &#x2014; nothing like an expert level, but if
you&rsquo;ve never used <code>init</code>, <code>add</code>, <code>rm</code>, <code>commit</code> or <code>checkout</code>, you will be
lost.</li>
<li>Language-wise, wyag will be implemented in <b>Python</b>.  Again, I won&rsquo;t
use anything too fancy, and Python looks like pseudo-code anyways,
so it will be easy to follow (ironically, the most complicated part
will be the command-line arguments parsing logic, and you don&rsquo;t
really need to understand that).  Yet, if you know programming but
have never done any Python, I suggest you find a crash course
somewhere in the internet just to get acquainted with the language.</li>
<li><code>wyag</code> and <code>git</code> are terminal programs.  I assume you know your way
inside a Unix terminal.  Again, you don&rsquo;t need to be a l77t h4x0r,
but <code>cd</code>, <code>ls</code>, <code>rm</code>, <code>tree</code> and their friends should be in your toolbox.</li>
</ul>

<div class="warning" id="org8a2529d">
<p>
<b>Note for Windows users</b>
</p>

<p>
<code>wyag</code> should run on any Unix-like system with a Python interpreter,
but I have absolutely no idea how it will behave on Windows.  The
test suite absolutely requires a bash-compatible shell, which I
assume the WSL can provide.  Also, if you are using WSL, make sure
your <code>wyag</code> file uses Unix-style line endings (<a href="https://stackoverflow.com/questions/48692741/how-can-i-make-all-line-endings-eols-in-all-files-in-visual-studio-code-unix">See this
StackOverflow solution if you use VS Code</a>).  Feedback from Windows
users would be appreciated!
</p>

</div>

<div class="note" id="org4cddcd0">
<p>
<b><b>Acknowledgments</b></b>
</p>

<p>
This article benefited from significant contributions from multiple
people, and I&rsquo;m grateful to them all.  Special thanks to:
</p>

<ul class="org-ul">
<li>Github user <a href="https://github.com/tammoippen">tammoippen</a>, who first drafted the <code>tag_create</code>
function I had simply… forgotten to write (that was <a href="https://github.com/thblt/write-yourself-a-git/issues/9">#9</a>).</li>
<li>Github user <a href="https://github.com/hjlarry">hjlarry</a> fixed multiple issues in <a href="https://github.com/thblt/write-yourself-a-git/pull/22">#22</a>.</li>
<li>GitHub user <a href="https://github.com/cutebbb">cutebbb</a> implemented the first version of ls-files in
<a href="https://github.com/thblt/write-yourself-a-git/pull/32/">#32</a>, and by doing so finally brought wyag to the wonders of the
staging area!</li>
</ul>

</div>
</div>
</div>
<div id="outline-container-getting-started" class="outline-2">
<h2 id="getting-started"><span class="section-number-2">2.</span> Getting started</h2>
<div class="outline-text-2" id="text-getting-started">
<p>
You&rsquo;re going to need Python 3.10 or higher, along with your
favorite text editor.  We won&rsquo;t need third party packages or
virtualenvs, or anything besides a regular Python interpreter:
everything we need is in Python&rsquo;s standard library.
</p>

<p>
We&rsquo;ll split the code into two files:
</p>

<ul class="org-ul">
<li>An executable, called <code>wyag</code>;</li>
<li>A Python library, called <code>libwyag.py</code>;</li>
</ul>

<p>
Now, every software project starts with a boatload of boilerplate, so
let&rsquo;s get this over with.
</p>

<p>
We&rsquo;ll begin by creating the (very short) executable.  Create a new
file called <code>wyag</code> in your text editor, and copy the following few
lines:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter">#</span><span class="org-comment">!/usr/bin/env python3</span>

<span class="org-keyword">import</span> libwyag
libwyag.main()
</pre>
</div>

<p>
Then make it executable:
</p>

<pre class="example" id="orga0ff55f">
$ chmod +x wyag
</pre>

<p>
You&rsquo;re done!
</p>

<p>
Now for the library.  it must be called <code>libwyag.py</code>, and be in the
same directory as the <code>wyag</code> executable.  Begin by opening the empty
<code>libwyag.py</code> in your text editor.
</p>

<p>
We&rsquo;re first going to need a bunch of imports (just copy each import,
or merge them all in a single line)
</p>

<ul class="org-ul">
<li><p>
Git is a CLI application, so we&rsquo;ll need something to parse
command-line arguments.  Python provides a cool module called
<a href="https://docs.python.org/3/library/argparse.html">argparse</a> that can do 99% of the job for us.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> argparse
</pre>
</div></li>

<li><p>
Git uses a configuration file format that is basically Microsoft&rsquo;s
INI format.  The <a href="https://docs.python.org/3/library/configparser.html">configparser</a> module can read and write these
files.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> configparser
</pre>
</div></li>

<li><p>
We&rsquo;ll be doing some date/time manipulation:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> datetime <span class="org-keyword">import</span> datetime
</pre>
</div></li>

<li><p>
We&rsquo;ll need, just once, to read the users/group database on Unix
(<code>grp</code> is for groups, <code>pwd</code> for users).  This is because git saves
the numerical owner/group ID of files, and we&rsquo;ll want to display
that nicely (as text):
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> grp, pwd
</pre>
</div></li>

<li><p>
To support <code>.gitignore</code>, we&rsquo;ll need to match filenames against
patterns like *.txt.  Filename matching is in… <code>fnmatch</code>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> fnmatch <span class="org-keyword">import</span> fnmatch
</pre>
</div></li>

<li><p>
Git uses the SHA-1 function quite extensively.  In Python, it&rsquo;s in <a href="https://docs.python.org/3/library/hashlib.html">hashlib</a>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> hashlib
</pre>
</div></li>

<li><p>
Just one function from <a href="https://docs.python.org/3/library/math.html">math</a>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> math <span class="org-keyword">import</span> ceil
</pre>
</div></li>

<li><p>
<a href="https://docs.python.org/3/library/os.html">os</a> and <a href="https://docs.python.org/3/library/os.path.html">os.path</a> provide some nice filesystem abstraction routines.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> os
</pre>
</div></li>

<li><p>
we use <i>just a bit</i> of regular expressions:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> re
</pre>
</div></li>

<li><p>
We also need <a href="https://docs.python.org/3/library/sys.html">sys</a> to access the actual command-line arguments (in <code>sys.argv</code>):
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> sys
</pre>
</div></li>

<li><p>
Git compresses everything using zlib.  Python <a href="https://docs.python.org/3/library/zlib.html">has that</a>, too:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> zlib
</pre>
</div></li>
</ul>

<p>
Imports are done.  We&rsquo;ll be working with command-line arguments a lot.
Python provides a simple yet reasonably powerful parsing library,
<code>argparse</code>.  It&rsquo;s a nice library, but its interface may not be the
most intuitive ever; if need, refer to its <a href="https://docs.python.org/3/library/argparse.html">documentation</a>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argparser</span> <span class="org-operator">=</span> argparse.ArgumentParser(description<span class="org-operator">=</span><span class="org-string">"The stupidest content tracker"</span>)
</pre>
</div>

<p>
We&rsquo;ll need to handle subcommands (as in git: <code>init</code>, <code>commit</code>, etc.)
In argparse slang, these are called &ldquo;subparsers&rdquo;.  At this point we
only need to declare that our CLI will use some, and that all
invocation will actually <i>require</i> one &#x2014; you don&rsquo;t just call <code>git</code>,
you call <code>git COMMAND</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argsubparsers</span> <span class="org-operator">=</span> argparser.add_subparsers(title<span class="org-operator">=</span><span class="org-string">"Commands"</span>, dest<span class="org-operator">=</span><span class="org-string">"command"</span>)
argsubparsers.<span class="org-variable-name">required</span> <span class="org-operator">=</span> <span class="org-constant">True</span>
</pre>
</div>

<p>
The <code>dest="command"</code> argument states that the name of the chosen
subparser will be returned as a string in a field called <code>command</code>.
So we just need to read this string and call the correct function
accordingly.  By convention, I&rsquo;ll call these functions &ldquo;bridges
functions&rdquo; and prefix their names by <code>cmd_</code>.  Bridge functions
take the parsed arguments as their unique parameter, and are
responsible for processing and validating them before executing the
actual command.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">main</span>(argv<span class="org-operator">=</span>sys.argv[1:]):
    <span class="org-variable-name">args</span> <span class="org-operator">=</span> argparser.parse_args(argv)
    <span class="org-keyword">match</span> args.command:
        <span class="org-keyword">case</span> <span class="org-string">"add"</span>          : cmd_add(args)
        <span class="org-keyword">case</span> <span class="org-string">"cat-file"</span>     : cmd_cat_file(args)
        <span class="org-keyword">case</span> <span class="org-string">"check-ignore"</span> : cmd_check_ignore(args)
        <span class="org-keyword">case</span> <span class="org-string">"checkout"</span>     : cmd_checkout(args)
        <span class="org-keyword">case</span> <span class="org-string">"commit"</span>       : cmd_commit(args)
        <span class="org-keyword">case</span> <span class="org-string">"hash-object"</span>  : cmd_hash_object(args)
        <span class="org-keyword">case</span> <span class="org-string">"init"</span>         : cmd_init(args)
        <span class="org-keyword">case</span> <span class="org-string">"log"</span>          : cmd_log(args)
        <span class="org-keyword">case</span> <span class="org-string">"ls-files"</span>     : cmd_ls_files(args)
        <span class="org-keyword">case</span> <span class="org-string">"ls-tree"</span>      : cmd_ls_tree(args)
        <span class="org-keyword">case</span> <span class="org-string">"rev-parse"</span>    : cmd_rev_parse(args)
        <span class="org-keyword">case</span> <span class="org-string">"rm"</span>           : cmd_rm(args)
        <span class="org-keyword">case</span> <span class="org-string">"show-ref"</span>     : cmd_show_ref(args)
        <span class="org-keyword">case</span> <span class="org-string">"status"</span>       : cmd_status(args)
        <span class="org-keyword">case</span> <span class="org-string">"tag"</span>          : cmd_tag(args)
        <span class="org-keyword">case</span> _              : <span class="org-builtin">print</span>(<span class="org-string">"Bad command."</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-init" class="outline-2">
<h2 id="init"><span class="section-number-2">3.</span> Creating repositories: init</h2>
<div class="outline-text-2" id="text-init">
<p>
Obviously, the first Git command in chronological <i>and</i> logical order is
<code>git init</code>, so we&rsquo;ll begin by creating <code>wyag init</code>.  To achieve this,
we&rsquo;re going to first need some very basic repository abstraction.
</p>
</div>
<div id="outline-container-GitRepository" class="outline-3">
<h3 id="GitRepository"><span class="section-number-3">3.1.</span> The Repository object</h3>
<div class="outline-text-3" id="text-GitRepository">
<p>
We&rsquo;ll obviously need some abstraction for a repository: almost every
time we run a git command, we&rsquo;re trying to do something to a
repository, to create it, read from it or modify it.
</p>

<p>
A git repository is made of two things: a “work tree”, where the files
meant to be in version control live, and a “git directory”, where Git
stores its own data.  In most cases, the worktree is a regular
directory and the git directory is a child directory of the worktree,
called <code>.git</code>.
</p>

<p>
Git supports <i>much more</i> cases (bare repo, separated gitdir, etc) but
we won&rsquo;t need them: we&rsquo;ll stick to the basic approach of
<code>worktree/.git</code>.  Our repository object will then just hold two paths:
the worktree and the gitdir.
</p>

<p>
To create a new <code>Repository</code> object, we only need to make a few checks:
</p>

<ul class="org-ul">
<li>We must verify that the directory exists, and contains a
subdirectory called <code>.git</code>.</li>

<li>We then read its configuration in <code>.git/config</code> (it&rsquo;s just an INI
file) and check that <code>core.repositoryformatversion</code> is 0.  More on
that field in a moment.</li>
</ul>

<p>
Our constructor takes an optional <code>force</code> argument which disables all
checks.  That&rsquo;s because the <code>repo_create()</code> function which we&rsquo;ll
create later will use a <code>Repository</code> object to <i>create</i> the repo.  So
we need a way to create such objects even from (still) invalid
filesystem locations.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">GitRepository</span> (<span class="org-builtin">object</span>):
    <span class="org-doc">"""A git repository"""</span>

    <span class="org-variable-name">worktree</span> <span class="org-operator">=</span> <span class="org-constant">None</span>
    <span class="org-variable-name">gitdir</span> <span class="org-operator">=</span> <span class="org-constant">None</span>
    <span class="org-variable-name">conf</span> <span class="org-operator">=</span> <span class="org-constant">None</span>

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, path, force<span class="org-operator">=</span><span class="org-constant">False</span>):
        <span class="org-keyword">self</span>.<span class="org-variable-name">worktree</span> <span class="org-operator">=</span> path
        <span class="org-keyword">self</span>.<span class="org-variable-name">gitdir</span> <span class="org-operator">=</span> os.path.join(path, <span class="org-string">".git"</span>)

        <span class="org-keyword">if</span> <span class="org-keyword">not</span> (force <span class="org-keyword">or</span> os.path.isdir(<span class="org-keyword">self</span>.gitdir)):
            <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(f<span class="org-string">"Not a Git repository </span>{path}<span class="org-string">"</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Read configuration file in .git/config</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">conf</span> <span class="org-operator">=</span> configparser.ConfigParser()
        <span class="org-variable-name">cf</span> <span class="org-operator">=</span> repo_file(<span class="org-keyword">self</span>, <span class="org-string">"config"</span>)

        <span class="org-keyword">if</span> cf <span class="org-keyword">and</span> os.path.exists(cf):
            <span class="org-keyword">self</span>.conf.read([cf])
        <span class="org-keyword">elif</span> <span class="org-keyword">not</span> force:
            <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(<span class="org-string">"Configuration file missing"</span>)

        <span class="org-keyword">if</span> <span class="org-keyword">not</span> force:
            <span class="org-variable-name">vers</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>(<span class="org-keyword">self</span>.conf.get(<span class="org-string">"core"</span>, <span class="org-string">"repositoryformatversion"</span>))
            <span class="org-keyword">if</span> vers <span class="org-operator">!=</span> 0:
                <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(<span class="org-string">"Unsupported repositoryformatversion: {vers}"</span>)
</pre>
</div>

<p>
We&rsquo;re going to be manipulating <b>lots</b> of paths in repositories.  We may
as well create a few utility functions to compute those paths and
create missing directory structures if needed.  First, just a general
path building function:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">repo_path</span>(repo, <span class="org-operator">*</span>path):
    <span class="org-doc">"""Compute path under repo's gitdir."""</span>
    <span class="org-keyword">return</span> os.path.join(repo.gitdir, <span class="org-operator">*</span>path)
</pre>
</div>

<p>
(A note on Python syntax: the star on the <code>*path</code> makes the function
variadic, so it can be called with multiple path components as
separate arguments.  For example, <code>repo_path(repo, "objects", "df",
"4ec9fc2ad990cb9da906a95a6eda6627d7b7b0")</code> is a valid call.  The
function receives <code>path</code> as a list)
</p>

<p>
The next two functions, <code>repo_file()</code> and <code>repo_dir()</code>, return and
optionally create a path to a file or a directory, respectively.  The
difference between them is that the file version only creates
directories up to the last component.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">repo_file</span>(repo, <span class="org-operator">*</span>path, mkdir<span class="org-operator">=</span><span class="org-constant">False</span>):
    <span class="org-doc">"""Same as repo_path, but create dirname(*path) if absent.  For</span>
<span class="org-doc">example, repo_file(r, \"refs\", \"remotes\", \"origin\", \"HEAD\") will create</span>
<span class="org-doc">.git/refs/remotes/origin."""</span>

    <span class="org-keyword">if</span> repo_dir(repo, <span class="org-operator">*</span>path[:<span class="org-operator">-</span>1], mkdir<span class="org-operator">=</span>mkdir):
        <span class="org-keyword">return</span> repo_path(repo, <span class="org-operator">*</span>path)

<span class="org-keyword">def</span> <span class="org-function-name">repo_dir</span>(repo, <span class="org-operator">*</span>path, mkdir<span class="org-operator">=</span><span class="org-constant">False</span>):
    <span class="org-doc">"""Same as repo_path, but mkdir *path if absent if mkdir."""</span>

    <span class="org-variable-name">path</span> <span class="org-operator">=</span> repo_path(repo, <span class="org-operator">*</span>path)

    <span class="org-keyword">if</span> os.path.exists(path):
        <span class="org-keyword">if</span> (os.path.isdir(path)):
            <span class="org-keyword">return</span> path
        <span class="org-keyword">else</span>:
            <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(f<span class="org-string">"Not a directory </span>{path}<span class="org-string">"</span>)

    <span class="org-keyword">if</span> mkdir:
        os.makedirs(path)
        <span class="org-keyword">return</span> path
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> <span class="org-constant">None</span>
</pre>
</div>

<p>
(Second and last note on syntax: because the star in <code>*path</code> makes the
functions variadic, the <code>mkdir</code> argument must be passed explicitly by
name.  For example, <code>repo_file(repo, "objects", mkdir=True)</code>.)
</p>

<p>
To <b>create</b> a new repository, we start with a directory (which we
create if doesn&rsquo;t already exist) and create the <b>git directory</b> inside
(which must not exist already, or be empty).  That directory is called
<code>.git</code> (the leading period makes it &ldquo;hidden&rdquo; on Unix systems), and contains:
</p>

<ul class="org-ul">
<li><code>.git/objects/</code> : the object store, which we&rsquo;ll introduce <a href="#objects">in the next section</a>.</li>
<li><code>.git/refs/</code> the reference store, which we&rsquo;ll discuss <a href="#cmd-show-ref">a bit later</a>.
It contains two subdirectories, <code>heads</code> and <code>tags</code>.</li>
<li><code>.git/HEAD</code>, a reference to the current HEAD (more on that later!)</li>
<li><code>.git/config</code>, the repository&rsquo;s configuration file.</li>
<li><code>.git/description</code>, holds a free-form description of this
repository&rsquo;s contents, for humans, and is rarely used.</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">repo_create</span>(path):
    <span class="org-doc">"""Create a new repository at path."""</span>

    <span class="org-variable-name">repo</span> <span class="org-operator">=</span> GitRepository(path, <span class="org-constant">True</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">First, we make sure the path either doesn't exist or is an</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">empty dir.</span>

    <span class="org-keyword">if</span> os.path.exists(repo.worktree):
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> os.path.isdir(repo.worktree):
            <span class="org-keyword">raise</span> <span class="org-type">Exception</span> (f<span class="org-string">"</span>{path}<span class="org-string"> is not a directory!"</span>)
        <span class="org-keyword">if</span> os.path.exists(repo.gitdir) <span class="org-keyword">and</span> os.listdir(repo.gitdir):
            <span class="org-keyword">raise</span> <span class="org-type">Exception</span> (f<span class="org-string">"</span>{path}<span class="org-string"> is not empty!"</span>)
    <span class="org-keyword">else</span>:
        os.makedirs(repo.worktree)

    <span class="org-keyword">assert</span> repo_dir(repo, <span class="org-string">"branches"</span>, mkdir<span class="org-operator">=</span><span class="org-constant">True</span>)
    <span class="org-keyword">assert</span> repo_dir(repo, <span class="org-string">"objects"</span>, mkdir<span class="org-operator">=</span><span class="org-constant">True</span>)
    <span class="org-keyword">assert</span> repo_dir(repo, <span class="org-string">"refs"</span>, <span class="org-string">"tags"</span>, mkdir<span class="org-operator">=</span><span class="org-constant">True</span>)
    <span class="org-keyword">assert</span> repo_dir(repo, <span class="org-string">"refs"</span>, <span class="org-string">"heads"</span>, mkdir<span class="org-operator">=</span><span class="org-constant">True</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">.git/description</span>
    <span class="org-keyword">with</span> <span class="org-builtin">open</span>(repo_file(repo, <span class="org-string">"description"</span>), <span class="org-string">"w"</span>) <span class="org-keyword">as</span> f:
        f.write(<span class="org-string">"Unnamed repository; edit this file 'description' to name the repository.</span><span class="org-constant">\n</span><span class="org-string">"</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">.git/HEAD</span>
    <span class="org-keyword">with</span> <span class="org-builtin">open</span>(repo_file(repo, <span class="org-string">"HEAD"</span>), <span class="org-string">"w"</span>) <span class="org-keyword">as</span> f:
        f.write(<span class="org-string">"ref: refs/heads/master</span><span class="org-constant">\n</span><span class="org-string">"</span>)

    <span class="org-keyword">with</span> <span class="org-builtin">open</span>(repo_file(repo, <span class="org-string">"config"</span>), <span class="org-string">"w"</span>) <span class="org-keyword">as</span> f:
        <span class="org-variable-name">config</span> <span class="org-operator">=</span> repo_default_config()
        config.write(f)

    <span class="org-keyword">return</span> repo
</pre>
</div>

<p>
The configuration file is very simple, it&rsquo;s a <a href="https://en.wikipedia.org/wiki/INI_file">INI</a>-like file with a
single section (<code>[core]</code>) and three fields:
</p>

<ul class="org-ul">
<li><code>repositoryformatversion = 0</code>: the version of
the gitdir format.  0 means the initial format, 1 the same with
extensions.  If &gt; 1, git will panic; wyag will only accept 0.</li>
<li><code>filemode = false</code>: disable tracking of file modes (permissions)
changes in the work tree.</li>
<li><code>bare = false</code>: indicates that this repository has a worktree.  Git
supports an optional <code>worktree</code> key which indicates the location of
the worktree, if not <code>..</code>; wyag doesn&rsquo;t.</li>
</ul>

<p>
We create this file using Python&rsquo;s <code>configparser</code> lib:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">repo_default_config</span>():
    <span class="org-variable-name">ret</span> <span class="org-operator">=</span> configparser.ConfigParser()

    ret.add_section(<span class="org-string">"core"</span>)
    ret.<span class="org-builtin">set</span>(<span class="org-string">"core"</span>, <span class="org-string">"repositoryformatversion"</span>, <span class="org-string">"0"</span>)
    ret.<span class="org-builtin">set</span>(<span class="org-string">"core"</span>, <span class="org-string">"filemode"</span>, <span class="org-string">"false"</span>)
    ret.<span class="org-builtin">set</span>(<span class="org-string">"core"</span>, <span class="org-string">"bare"</span>, <span class="org-string">"false"</span>)

    <span class="org-keyword">return</span> ret
</pre>
</div>
</div>
</div>
<div id="outline-container-cmd-init" class="outline-3">
<h3 id="cmd-init"><span class="section-number-3">3.2.</span> The init command</h3>
<div class="outline-text-3" id="text-cmd-init">
<p>
Now that we have code to read and create repositories, let&rsquo;s make this
code usable from the command line by creating the <code>wyag init</code> command.
<code>wyag init</code> behaves just like <code>git init</code> &#x2014; with much less
customizability, of course.  The syntax of <code>wyag init</code> is going to be:
</p>

<pre class="example" id="org2868070">
wyag init [path]
</pre>

<p>
We already have the complete repository creation logic.  To create the
command, we&rsquo;re only going to need two more things:
</p>

<ol class="org-ol">
<li><p>
We need to create an argparse subparser to handle our command&rsquo;s
argument.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argsp</span> <span class="org-operator">=</span> argsubparsers.add_parser(<span class="org-string">"init"</span>, <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Initialize a new, empty repository."</span>)
</pre>
</div>

<p>
In the case of <code>init</code>, there&rsquo;s a single, optional,
positional argument: the path where to init the repo.  It defaults
to <code>.</code>, the current directory:
</p>

<div class="org-src-container">
<pre class="src src-python">argsp.add_argument(<span class="org-string">"path"</span>,
                   metavar<span class="org-operator">=</span><span class="org-string">"directory"</span>,
                   nargs<span class="org-operator">=</span><span class="org-string">"?"</span>,
                   default<span class="org-operator">=</span><span class="org-string">"."</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Where to create the repository."</span>)

</pre>
</div></li>

<li><p>
We also need a &ldquo;bridge&rdquo; function that will read argument values
from the object returned by argparse and call the actual
function with correct values.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cmd_init</span>(args):
    repo_create(args.path)
</pre>
</div></li>
</ol>

<p>
And we&rsquo;re done!  If you&rsquo;ve followed these steps, you should now be
able to <code>wyag init</code> a git repository anywhere:
</p>

<pre class="example" id="org29c370d">
$ wyag init test
</pre>

<p>
(The <code>wyag</code> executable won&rsquo;t usually be in your <code>$PATH</code>: you&rsquo;ll want to call it by its
full name, eg <code>~/projects/wyag/wyag init .</code>)
</p>
</div>
</div>
<div id="outline-container-org2a7c67b" class="outline-3">
<h3 id="org2a7c67b"><span class="section-number-3">3.3.</span> The repo_find() function</h3>
<div class="outline-text-3" id="text-3-3">
<p>
While we&rsquo;re implementing repositories, we&rsquo;re going to need a function
to find the root of the current repository.  We&rsquo;ll use it a lot, since
almost all Git functions work on an existing repository (except
<code>init</code>, of course!).  Sometimes that root is the current directory,
but it may also be a parent: your repository&rsquo;s root may be in
<code>~/Documents/MyProject</code>, but you may currently be working in
<code>~/Documents/MyProject/src/tui/frames/mainview/</code>.  The <code>repo_find()</code>
function we&rsquo;ll now create will look for that root, starting at the
current directory and recursing back to <code>/</code>.  To identify a path as a
repository, it will check for the presence of a <code>.git</code> directory.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">repo_find</span>(path<span class="org-operator">=</span><span class="org-string">"."</span>, required<span class="org-operator">=</span><span class="org-constant">True</span>):
    <span class="org-variable-name">path</span> <span class="org-operator">=</span> os.path.realpath(path)

    <span class="org-keyword">if</span> os.path.isdir(os.path.join(path, <span class="org-string">".git"</span>)):
        <span class="org-keyword">return</span> GitRepository(path)

    <span class="org-comment-delimiter"># </span><span class="org-comment">If we haven't returned, recurse in parent, if w</span>
    <span class="org-variable-name">parent</span> <span class="org-operator">=</span> os.path.realpath(os.path.join(path, <span class="org-string">".."</span>))

    <span class="org-keyword">if</span> parent <span class="org-operator">==</span> path:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Bottom case</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">os.path.join("/", "..") == "/":</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">If parent==path, then path is root.</span>
        <span class="org-keyword">if</span> required:
            <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(<span class="org-string">"No git directory."</span>)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> <span class="org-constant">None</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Recursive case</span>
    <span class="org-keyword">return</span> repo_find(parent, required)
</pre>
</div>

<p>
And we&rsquo;re done with repositories!
</p>
</div>
</div>
</div>
<div id="outline-container-objects" class="outline-2">
<h2 id="objects"><span class="section-number-2">4.</span> Reading and writing objects: hash-object and cat-file</h2>
<div class="outline-text-2" id="text-objects">
</div>
<div id="outline-container-objects-intro" class="outline-3">
<h3 id="objects-intro"><span class="section-number-3">4.1.</span> What are objects?</h3>
<div class="outline-text-3" id="text-objects-intro">
<p>
Now that we have repositories, putting things inside them is in order.
Also, repositories are boring, and writing a Git implementation
shouldn&rsquo;t be just a matter of writing a bunch of <code>mkdir</code>.  Let&rsquo;s talk
about <b>objects</b>, and let&rsquo;s implement <code>git hash-object</code> and <code>git cat-file</code>.
</p>

<p>
Maybe you don&rsquo;t know these two commands &#x2014; they&rsquo;re not exactly part
of an everyday git toolbox, and they&rsquo;re actually quite low-level
(&ldquo;plumbing&rdquo;, in git parlance).  What they do is actually very simple:
<code>hash-object</code> converts an existing file into a git object, and <code>cat-file</code>
prints an existing git object to the standard output.
</p>

<p>
Now, <b>what actually is a Git object?</b> At its core, Git is a
&ldquo;content-addressed filesystem&rdquo;.  That means that unlike regular
filesystems, where the name of a file is arbitrary and unrelated to
that file&rsquo;s contents, the names of files as stored by Git are
mathematically derived from their contents.  This has a very important
implication: if a single byte of, say, a text file, changes, its
internal name will change, too.  To put it simply: you don&rsquo;t <i>modify</i>
a file in git, you create a new file in a different location.  Objects
are just that: <b>files in the git repository, whose paths are
determined by their contents</b>.
</p>

<div class="warning" id="orge49516b">
<p>
<b>Git is not (really) a key-value store</b>
</p>

<p>
Some documentation, including the excellent <a href="https://git-scm.com/book/id/v2/Git-Internals-Git-Objects">Pro Git</a>, call Git a
&ldquo;key-value store&rdquo;.  This is not incorrect, but may be misleading.
Regular filesystems are actually closer to a key-value store than Git
is.  Because it computes keys from data, Git could rather be called a
<i>value-value store</i>.
</p>

</div>

<p>
Git uses objects to store quite a lot of things: first and foremost,
the actual files it keeps in version control &#x2014; source code, for
example.  Commit are objects, too, as well as tags.  With a few
notable exceptions (which we&rsquo;ll see later!), almost everything, in
Git, is stored as an object.
</p>

<p>
The path where git stores a given object is computed by calculating
the <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">hash</a> of its contents.  More precisely, Git renders the hash
as a lowercase hexadecimal string, and splits it in two parts: the
first two characters, and the rest.  It uses the first part as a
directory name, the rest as the file name (this is because most
filesystems hate having too many files in a single directory and would
slow down to a crawl.  Git&rsquo;s method creates 256 possible intermediate
directories, hence dividing the average number of files per directory
by 256)
</p>

<div class="note" id="orgae9b34e">
<p>
<b>What is a hash function?</b>
</p>

<p>
SHA-1 is what we call a “hash function”. Simply put, a hash function
is a kind of unidirectional mathematical function: it is easy to
compute the hash of a value, but there&rsquo;s no way to compute back which
value produced a hash.
</p>

<p>
A very simple example of a hash function is the classical <code>len</code> (or
<code>strlen</code>) function, which returns the length of a string.  It&rsquo;s really
easy to compute the length of a string, and the length of a given
string will never change (unless the string itself changes, of
course!) but it&rsquo;s impossible to retrieve the original string, given
only its length.  <i>Cryptographic</i> hash functions are a much more
complex version of the same, with the added property that computing an
input meant to produce a given hash is hard enough to be practically
impossible.  (To produce an input <code>i</code> with <code>strlen(i) == 12</code>, you just
type twelve random characters.  With algorithms such as SHA-1. it
would take much, much longer &#x2014; long enough to be practically
impossible<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>).
</p>

</div>

<p>
Before we start implementing the object storage system, we must
understand their exact storage format.  An object starts with a header
that specifies its type: <code>blob</code>, <code>commit</code>, <code>tag</code> or <code>tree</code> (more on
that in a second).  This header is followed by an ASCII space (0x20),
then the size of the object in bytes as an ASCII number, then null
(0x00) (the null byte), then the contents of the object.  The first 48
bytes of a commit object in Wyag&rsquo;s repo look like this:
</p>

<pre class="example" id="orgf008526">
00000000  63 6f 6d 6d 69 74 20 31  30 38 36 00 74 72 65 65  |commit 1086.tree|
00000010  20 32 39 66 66 31 36 63  39 63 31 34 65 32 36 35  | 29ff16c9c14e265|
00000020  32 62 32 32 66 38 62 37  38 62 62 30 38 61 35 61  |2b22f8b78bb08a5a|
</pre>

<p>
In the first line, we see the type header, a space (<code>0x20</code>), the size in
ASCII (1086) and the null separator <code>0x00</code>.  The last four bytes on the
first line are the beginning of that object&rsquo;s contents, the word
&ldquo;tree&rdquo; &#x2014; we&rsquo;ll discuss that further when we&rsquo;ll talk about commits.
</p>

<p>
The objects (headers and contents) are stored compressed with <code>zlib</code>.
</p>
</div>
</div>
<div id="outline-container-org6464558" class="outline-3">
<h3 id="org6464558"><span class="section-number-3">4.2.</span> A generic object object</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Objects can be of multiple types, but they all share the same
storage/retrieval mechanism and the same general header format.
Before we dive into the details of various types of objects, we need
to abstract over these common features.  The easiest way is to create
a generic <code>GitObject</code> with two unimplemented methods: <code>serialize()</code>
and <code>deserialize()</code>, and a default <code>init()</code> to create a new, empty
object if needed (sorry pythonistas, this isn&rsquo;t very nice design but
it&rsquo;s probably easier to read than superconstructors).  Our <code>__init__</code>
either loads the object from the provided data, or calls the
subclass-provided <code>init()</code> to create a new, empty object.
</p>

<p>
Later, we&rsquo;ll subclass this generic class, actually implementing these
functions for each object format.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">GitObject</span> (<span class="org-builtin">object</span>):

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, data<span class="org-operator">=</span><span class="org-constant">None</span>):
        <span class="org-keyword">if</span> data <span class="org-operator">!=</span> <span class="org-constant">None</span>:
            <span class="org-keyword">self</span>.deserialize(data)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">self</span>.init()

    <span class="org-keyword">def</span> <span class="org-function-name">serialize</span>(<span class="org-keyword">self</span>, repo):
        <span class="org-doc">"""This function MUST be implemented by subclasses.</span>

<span class="org-doc">It must read the object's contents from self.data, a byte string, and</span>
<span class="org-doc">do whatever it takes to convert it into a meaningful representation.</span>
<span class="org-doc">What exactly that means depend on each subclass.</span>

<span class="org-doc">        """</span>
        <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(<span class="org-string">"Unimplemented!"</span>)

    <span class="org-keyword">def</span> <span class="org-function-name">deserialize</span>(<span class="org-keyword">self</span>, data):
        <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(<span class="org-string">"Unimplemented!"</span>)

    <span class="org-keyword">def</span> <span class="org-function-name">init</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">pass</span> <span class="org-comment-delimiter"># </span><span class="org-comment">Just do nothing. This is a reasonable default!</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-object_read" class="outline-3">
<h3 id="object_read"><span class="section-number-3">4.3.</span> Reading objects</h3>
<div class="outline-text-3" id="text-object_read">
<p>
To read an object, we need to know its SHA-1 hash.  We then compute
its path from this hash (with the formula explained above: first two
characters, then a directory delimiter <code>/</code>, then the remaining part)
and look it up inside of the &ldquo;objects&rdquo; directory in the gitdir.  That
is, the path to <code>e673d1b7eaa0aa01b5bc2442d570a765bdaae751</code> is
<code>.git/objects/e6/73d1b7eaa0aa01b5bc2442d570a765bdaae751</code>.
</p>

<p>
We then read that file as a binary file, and decompress it using
<code>zlib</code>.
</p>

<p>
From the decompressed data, we extract the two header components: the
object type and its size.   From the type, we determine the actual
class to use.   We convert the size to a Python integer, and check if
it matches.
</p>

<p>
When all is done, we just call the correct constructor for that
object&rsquo;s format.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">object_read</span>(repo, sha):
    <span class="org-doc">"""Read object sha from Git repository repo.  Return a</span>
<span class="org-doc">    GitObject whose exact type depends on the object."""</span>

    <span class="org-variable-name">path</span> <span class="org-operator">=</span> repo_file(repo, <span class="org-string">"objects"</span>, sha[0:2], sha[2:])

    <span class="org-keyword">if</span> <span class="org-keyword">not</span> os.path.isfile(path):
        <span class="org-keyword">return</span> <span class="org-constant">None</span>

    <span class="org-keyword">with</span> <span class="org-builtin">open</span> (path, <span class="org-string">"rb"</span>) <span class="org-keyword">as</span> f:
        <span class="org-variable-name">raw</span> <span class="org-operator">=</span> zlib.decompress(f.read())

        <span class="org-comment-delimiter"># </span><span class="org-comment">Read object type</span>
        <span class="org-variable-name">x</span> <span class="org-operator">=</span> raw.find(b<span class="org-string">' '</span>)
        <span class="org-variable-name">fmt</span> <span class="org-operator">=</span> raw[0:x]

        <span class="org-comment-delimiter"># </span><span class="org-comment">Read and validate object size</span>
        <span class="org-variable-name">y</span> <span class="org-operator">=</span> raw.find(b<span class="org-string">'</span><span class="org-constant">\x00</span><span class="org-string">'</span>, x)
        <span class="org-variable-name">size</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>(raw[x:y].decode(<span class="org-string">"ascii"</span>))
        <span class="org-keyword">if</span> size <span class="org-operator">!=</span> <span class="org-builtin">len</span>(raw)<span class="org-operator">-</span>y<span class="org-operator">-</span>1:
            <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(f<span class="org-string">"Malformed object </span>{sha}<span class="org-string">: bad length"</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Pick constructor</span>
        <span class="org-keyword">match</span> fmt:
            <span class="org-keyword">case</span> b<span class="org-string">'commit'</span> : <span class="org-variable-name">c</span><span class="org-operator">=</span>GitCommit
            <span class="org-keyword">case</span> b<span class="org-string">'tree'</span>   : <span class="org-variable-name">c</span><span class="org-operator">=</span>GitTree
            <span class="org-keyword">case</span> b<span class="org-string">'tag'</span>    : <span class="org-variable-name">c</span><span class="org-operator">=</span>GitTag
            <span class="org-keyword">case</span> b<span class="org-string">'blob'</span>   : <span class="org-variable-name">c</span><span class="org-operator">=</span>GitBlob
            <span class="org-keyword">case</span> _:
                <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(f<span class="org-string">"Unknown type </span>{fmt.decode(<span class="org-string">"</span><span class="org-builtin">ascii</span><span class="org-string">")} for object {sha}"</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Call constructor and return object</span>
        <span class="org-keyword">return</span> c(raw[y<span class="org-operator">+</span>1:])
</pre>
</div>
</div>
</div>
<div id="outline-container-org54f0022" class="outline-3">
<h3 id="org54f0022"><span class="section-number-3">4.4.</span> Writing objects</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Writing an object is reading it in reverse: we compute the hash,
insert the header, zlib-compress everything and write the result in
the correct location.  This really shouldn&rsquo;t require much explanation,
just notice that the hash is computed <b>after</b> the header is added (so
it&rsquo;s the hash of the object itself, uncompressed, not just its contents)
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">object_write</span>(obj, repo<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Serialize object data</span>
    <span class="org-variable-name">data</span> <span class="org-operator">=</span> obj.serialize()
    <span class="org-comment-delimiter"># </span><span class="org-comment">Add header</span>
    <span class="org-variable-name">result</span> <span class="org-operator">=</span> obj.fmt <span class="org-operator">+</span> b<span class="org-string">' '</span> <span class="org-operator">+</span> <span class="org-builtin">str</span>(<span class="org-builtin">len</span>(data)).encode() <span class="org-operator">+</span> b<span class="org-string">'</span><span class="org-constant">\x00</span><span class="org-string">'</span> <span class="org-operator">+</span> data
    <span class="org-comment-delimiter"># </span><span class="org-comment">Compute hash</span>
    <span class="org-variable-name">sha</span> <span class="org-operator">=</span> hashlib.sha1(result).hexdigest()

    <span class="org-keyword">if</span> repo:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Compute path</span>
        <span class="org-variable-name">path</span><span class="org-operator">=</span>repo_file(repo, <span class="org-string">"objects"</span>, sha[0:2], sha[2:], mkdir<span class="org-operator">=</span><span class="org-constant">True</span>)

        <span class="org-keyword">if</span> <span class="org-keyword">not</span> os.path.exists(path):
            <span class="org-keyword">with</span> <span class="org-builtin">open</span>(path, <span class="org-string">'wb'</span>) <span class="org-keyword">as</span> f:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Compress and write</span>
                f.write(zlib.compress(result))
    <span class="org-keyword">return</span> sha
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfe7c2d7" class="outline-3">
<h3 id="orgfe7c2d7"><span class="section-number-3">4.5.</span> Working with blobs</h3>
<div class="outline-text-3" id="text-4-5">
<p>
We said earlier that the type header could be one of four: <code>blob</code>,
<code>commit</code>, <code>tag</code> and <code>tree</code> &#x2014; so git has four object types.
</p>

<p>
Blobs are the simplest of those four types, because they have no
actual format.  Blobs are user data: the content of every file you put
in git (<code>main.c</code>, <code>logo.png</code>, <code>README.md</code>) is stored as a blob.  That
makes them easy to manipulate, because they have no actual syntax or
constraints beyond the basic object storage mechanism: they&rsquo;re just
unspecified data.  Creating a <code>GitBlob</code> class is thus trivial, the
<code>serialize</code> and <code>deserialize</code> functions just have to store and return
their input unmodified.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">GitBlob</span>(GitObject):
    <span class="org-variable-name">fmt</span><span class="org-operator">=</span>b<span class="org-string">'blob'</span>

    <span class="org-keyword">def</span> <span class="org-function-name">serialize</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.blobdata

    <span class="org-keyword">def</span> <span class="org-function-name">deserialize</span>(<span class="org-keyword">self</span>, data):
        <span class="org-keyword">self</span>.<span class="org-variable-name">blobdata</span> <span class="org-operator">=</span> data
</pre>
</div>
</div>
</div>
<div id="outline-container-cmd-cat-file" class="outline-3">
<h3 id="cmd-cat-file"><span class="section-number-3">4.6.</span> The cat-file command</h3>
<div class="outline-text-3" id="text-cmd-cat-file">
<p>
We can now create <code>wyag cat-file</code>.  <code>git cat-file</code> simply prints the
raw contents of an object to stdout, uncompressed and without the git
header.  In a clone of <a href="https://github.com/thblt/write-yourself-a-git">wyag&rsquo;s source repository</a>, <code>git cat-file blob
e0695f14a412c29e252c998c81de1dde59658e4a</code> will show a version of the
README.
</p>

<p>
Our simplified version will just take those two positional arguments:
a type and an object identifier:
</p>

<pre class="example" id="org2c526c1">
wyag cat-file TYPE OBJECT
</pre>

<p>
The subparser is very simple:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argsp</span> <span class="org-operator">=</span> argsubparsers.add_parser(<span class="org-string">"cat-file"</span>,
                                 <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Provide content of repository objects"</span>)

argsp.add_argument(<span class="org-string">"type"</span>,
                   metavar<span class="org-operator">=</span><span class="org-string">"type"</span>,
                   choices<span class="org-operator">=</span>[<span class="org-string">"blob"</span>, <span class="org-string">"commit"</span>, <span class="org-string">"tag"</span>, <span class="org-string">"tree"</span>],
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Specify the type"</span>)

argsp.add_argument(<span class="org-string">"object"</span>,
                   metavar<span class="org-operator">=</span><span class="org-string">"object"</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"The object to display"</span>)
</pre>
</div>

<p>
And we can implement the functions, which just call into existing code we wrote earlier:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cmd_cat_file</span>(args):
    <span class="org-variable-name">repo</span> <span class="org-operator">=</span> repo_find()
    cat_file(repo, args.<span class="org-builtin">object</span>, fmt<span class="org-operator">=</span>args.<span class="org-builtin">type</span>.encode())

<span class="org-keyword">def</span> <span class="org-function-name">cat_file</span>(repo, obj, fmt<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-variable-name">obj</span> <span class="org-operator">=</span> object_read(repo, object_find(repo, obj, fmt<span class="org-operator">=</span>fmt))
    sys.stdout.<span class="org-builtin">buffer</span>.write(obj.serialize())
</pre>
</div>

<p>
<a id="orgdffd24d"></a> This function calls an <code>object_find</code>
function we haven&rsquo;t introduced yet.  For now, it&rsquo;s just going to
return one of its arguments unmodified, like this:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">object_find</span>(repo, name, fmt<span class="org-operator">=</span><span class="org-constant">None</span>, follow<span class="org-operator">=</span><span class="org-constant">True</span>):
    <span class="org-keyword">return</span> name
</pre>
</div>

<p>
The reason for this strange small function is that Git has a <i>lot</i> of
ways to refer to objects: full hash, short hash, tags&#x2026;
<code>object_find()</code> will be our name resolution function.  We&rsquo;ll only
implement it <a href="#object_find">later</a>, so this is just a temporary placeholder.  This
means that until we implement the real thing, the only way we can
refer to an object will be by its full hash.
</p>
</div>
</div>
<div id="outline-container-cmd-hash-object" class="outline-3">
<h3 id="cmd-hash-object"><span class="section-number-3">4.7.</span> The hash-object command</h3>
<div class="outline-text-3" id="text-cmd-hash-object">
<p>
We will want to put our <i>own</i> data in our repositories,
though. <code>hash-object</code> is basically the opposite of <code>cat-file</code>: it
reads a file, computes its hash as an object, either storing it in the
repository (if the -w flag is passed) or just printing its hash.
</p>

<p>
The syntax of <code>wyag hash-object</code> is a simplification of <code>git
hash-object</code>:
</p>

<pre class="example" id="org2e4fdcb">
wyag hash-object [-w] [-t TYPE] FILE
</pre>

<p>
Which converts to:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argsp</span> <span class="org-operator">=</span> argsubparsers.add_parser(
    <span class="org-string">"hash-object"</span>,
    <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Compute object ID and optionally creates a blob from a file"</span>)

argsp.add_argument(<span class="org-string">"-t"</span>,
                   metavar<span class="org-operator">=</span><span class="org-string">"type"</span>,
                   dest<span class="org-operator">=</span><span class="org-string">"type"</span>,
                   choices<span class="org-operator">=</span>[<span class="org-string">"blob"</span>, <span class="org-string">"commit"</span>, <span class="org-string">"tag"</span>, <span class="org-string">"tree"</span>],
                   default<span class="org-operator">=</span><span class="org-string">"blob"</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Specify the type"</span>)

argsp.add_argument(<span class="org-string">"-w"</span>,
                   dest<span class="org-operator">=</span><span class="org-string">"write"</span>,
                   action<span class="org-operator">=</span><span class="org-string">"store_true"</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Actually write the object into the database"</span>)

argsp.add_argument(<span class="org-string">"path"</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Read object from &lt;file&gt;"</span>)
</pre>
</div>

<p>
The actual implementation is very simple.  As usual, we create a small
bridge function:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cmd_hash_object</span>(args):
    <span class="org-keyword">if</span> args.write:
        <span class="org-variable-name">repo</span> <span class="org-operator">=</span> repo_find()
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">repo</span> <span class="org-operator">=</span> <span class="org-constant">None</span>

    <span class="org-keyword">with</span> <span class="org-builtin">open</span>(args.path, <span class="org-string">"rb"</span>) <span class="org-keyword">as</span> fd:
        <span class="org-variable-name">sha</span> <span class="org-operator">=</span> object_hash(fd, args.<span class="org-builtin">type</span>.encode(), repo)
        <span class="org-builtin">print</span>(sha)
</pre>
</div>

<p>
The actual implementation is also trivial.  The <code>repo</code> argument is
optional, and the object isn&rsquo;t written if it is <code>None</code> (this is
handled in <code>object_write()</code>, above):
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">object_hash</span>(fd, fmt, repo<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-doc">""" Hash object, writing it to repo if provided."""</span>
    <span class="org-variable-name">data</span> <span class="org-operator">=</span> fd.read()

    <span class="org-comment-delimiter"># </span><span class="org-comment">Choose constructor according to fmt argument</span>
    <span class="org-keyword">match</span> fmt:
        <span class="org-keyword">case</span> b<span class="org-string">'commit'</span> : <span class="org-variable-name">obj</span><span class="org-operator">=</span>GitCommit(data)
        <span class="org-keyword">case</span> b<span class="org-string">'tree'</span>   : <span class="org-variable-name">obj</span><span class="org-operator">=</span>GitTree(data)
        <span class="org-keyword">case</span> b<span class="org-string">'tag'</span>    : <span class="org-variable-name">obj</span><span class="org-operator">=</span>GitTag(data)
        <span class="org-keyword">case</span> b<span class="org-string">'blob'</span>   : <span class="org-variable-name">obj</span><span class="org-operator">=</span>GitBlob(data)
        <span class="org-keyword">case</span> _: <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(f<span class="org-string">"Unknown type </span>{fmt}<span class="org-string">!"</span>)

    <span class="org-keyword">return</span> object_write(obj, repo)
</pre>
</div>
</div>
</div>
<div id="outline-container-packfiles" class="outline-3">
<h3 id="packfiles"><span class="section-number-3">4.8.</span> Aside: what about packfiles?</h3>
<div class="outline-text-3" id="text-packfiles">
<p>
What we&rsquo;ve just implemented is called &ldquo;loose objects&rdquo;.  Git has a
second object storage mechanism called packfiles.  Packfiles are much
more efficient, but also much more complex, than loose objects.  Simply
put, a packfile is a compilation of loose objects (like a <code>tar</code>) but
some are stored as deltas (as a transformation of another object).
Packfiles are way too complex to be supported by wyag.
</p>

<p>
The packfile is stored in <code>.git/objects/pack/</code>.  It has a <code>.pack</code>
extension, and is accompanied by an index file of the same name with
the <code>.idx</code> extension.  Should you want to convert a packfile to loose
objects format (to play with <code>wyag</code> on an existing repo, for example),
here&rsquo;s the solution.
</p>

<p>
First, <i>move</i> the packfile outside the gitdir (just copying it won&rsquo;t work).
</p>

<div class="org-src-container">
<pre class="src src-shell">mv .git/objects/pack/pack-d9ef004d4ca729287f12aaaacf36fee39baa7c9d.pack .
</pre>
</div>

<p>
You can ignore the <code>.idx</code>.  Then, from the worktree, just <code>cat</code> it and pipe the result to <code>git
unpack-objects</code>:
</p>

<div class="org-src-container">
<pre class="src src-shell">cat pack-d9ef004d4ca729287f12aaaacf36fee39baa7c9d.pack | git unpack-objects
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd9ed94e" class="outline-2">
<h2 id="orgd9ed94e"><span class="section-number-2">5.</span> Reading commit history: log</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgb06b20e" class="outline-3">
<h3 id="orgb06b20e"><span class="section-number-3">5.1.</span> Parsing commits</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Now that we can read and write objects, we should consider commits.
A commit object (uncompressed, without headers) looks like this:
</p>

<pre class="example" id="org2015feb">
tree 29ff16c9c14e2652b22f8b78bb08a5a07930c147
parent 206941306e8a8af65b66eaaaea388a7ae24d49a0
author Thibault Polge &lt;thibault@thb.lt&gt; 1527025023 +0200
committer Thibault Polge &lt;thibault@thb.lt&gt; 1527025044 +0200
gpgsig -----BEGIN PGP SIGNATURE-----

 iQIzBAABCAAdFiEExwXquOM8bWb4Q2zVGxM2FxoLkGQFAlsEjZQACgkQGxM2FxoL
 kGQdcBAAqPP+ln4nGDd2gETXjvOpOxLzIMEw4A9gU6CzWzm+oB8mEIKyaH0UFIPh
 rNUZ1j7/ZGFNeBDtT55LPdPIQw4KKlcf6kC8MPWP3qSu3xHqx12C5zyai2duFZUU
 wqOt9iCFCscFQYqKs3xsHI+ncQb+PGjVZA8+jPw7nrPIkeSXQV2aZb1E68wa2YIL
 3eYgTUKz34cB6tAq9YwHnZpyPx8UJCZGkshpJmgtZ3mCbtQaO17LoihnqPn4UOMr
 V75R/7FjSuPLS8NaZF4wfi52btXMSxO/u7GuoJkzJscP3p4qtwe6Rl9dc1XC8P7k
 NIbGZ5Yg5cEPcfmhgXFOhQZkD0yxcJqBUcoFpnp2vu5XJl2E5I/quIyVxUXi6O6c
 /obspcvace4wy8uO0bdVhc4nJ+Rla4InVSJaUaBeiHTW8kReSFYyMmDCzLjGIu1q
 doU61OM3Zv1ptsLu3gUE6GU27iWYj2RWN3e3HE4Sbd89IFwLXNdSuM0ifDLZk7AQ
 WBhRhipCCgZhkj9g2NEk7jRVslti1NdN5zoQLaJNqSwO1MtxTmJ15Ksk3QP6kfLB
 Q52UWybBzpaP9HEd4XnR+HuQ4k2K0ns2KgNImsNvIyFwbpMUyUWLMPimaV1DWUXo
 5SBjDB/V/W2JBFR+XKHFJeFwYhj7DD/ocsGr4ZMx/lgc8rjIBkI=
 =lgTX
 -----END PGP SIGNATURE-----

Create first draft
</pre>

<p>
The format is a simplified version of mail messages, as specified in
<a href="https://www.ietf.org/rfc/rfc2822.txt">RFC 2822</a>.  It begins with a series of key-value pairs, with space as
the key/value separator, and ends with the commit message, that may
span over multiple lines.  Values may continue over multiple lines,
subsequent lines start with a space which the parser must drop (like
the <code>gpgsig</code> field above, which spans over 16 lines).
</p>

<p>
Let&rsquo;s have a look at those fields:
</p>

<ul class="org-ul">
<li><code>tree</code> is a reference to a tree object, a type of object that we&rsquo;ll
see just next.  A tree maps blobs IDs to filesystem locations, and
describes a state of the work tree.  Put simply, it is the actual
content of the commit: file contents, and where they go.</li>
<li><code>parent</code> is a reference to the parent of this commit.  It may be
repeated: merge commits, for example, have multiple parents.  It
may also be absent: the very first commit in a repository obviously
doesn&rsquo;t have a parent.</li>
<li><code>author</code> and <code>committer</code> are separate, because the author of a commit
is not necessarily the person who can commit it (This may not be
obvious for GitHub users, but a lot of projects do Git through e-mail)</li>
<li><code>gpgsig</code> is the PGP signature of this object.</li>
</ul>

<p>
We&rsquo;ll start by writing a simple parser for the format.  The code is
obvious.  The name of the function we&rsquo;re about to create,
<code>kvlm_parse()</code>, may be confusing: it isn&rsquo;t called <code>commit_parse()</code> because
tags have the very same format, so we&rsquo;ll use it for both objects types.
I use KVLM to mean &ldquo;Key-Value List with Message&rdquo;.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">kvlm_parse</span>(raw, start<span class="org-operator">=</span>0, dct<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> dct:
        <span class="org-variable-name">dct</span> <span class="org-operator">=</span> <span class="org-builtin">dict</span>()
        <span class="org-comment-delimiter"># </span><span class="org-comment">You CANNOT declare the argument as dct=dict() or all call to</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">the functions will endlessly grow the same dict.</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">This function is recursive: it reads a key/value pair, then call</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">itself back with the new position.  So we first need to know</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">where we are: at a keyword, or already in the messageQ</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">We search for the next space and the next newline.</span>
    <span class="org-variable-name">spc</span> <span class="org-operator">=</span> raw.find(b<span class="org-string">' '</span>, start)
    <span class="org-variable-name">nl</span> <span class="org-operator">=</span> raw.find(b<span class="org-string">'</span><span class="org-constant">\n</span><span class="org-string">'</span>, start)

    <span class="org-comment-delimiter"># </span><span class="org-comment">If space appears before newline, we have a keyword.  Otherwise,</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">it's the final message, which we just read to the end of the file.</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Base case</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">=========</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">If newline appears first (or there's no space at all, in which</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">case find returns -1), we assume a blank line.  A blank line</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">means the remainder of the data is the message.  We store it in</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">the dictionary, with None as the key, and return.</span>
    <span class="org-keyword">if</span> (spc <span class="org-operator">&lt;</span> 0) <span class="org-keyword">or</span> (nl <span class="org-operator">&lt;</span> spc):
        <span class="org-keyword">assert</span> nl <span class="org-operator">==</span> start
        <span class="org-variable-name">dct</span>[<span class="org-constant">None</span>] <span class="org-operator">=</span> raw[start<span class="org-operator">+</span>1:]
        <span class="org-keyword">return</span> dct

    <span class="org-comment-delimiter"># </span><span class="org-comment">Recursive case</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">==============</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">we read a key-value pair and recurse for the next.</span>
    <span class="org-variable-name">key</span> <span class="org-operator">=</span> raw[start:spc]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Find the end of the value.  Continuation lines begin with a</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">space, so we loop until we find a "\n" not followed by a space.</span>
    <span class="org-variable-name">end</span> <span class="org-operator">=</span> start
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-variable-name">end</span> <span class="org-operator">=</span> raw.find(b<span class="org-string">'</span><span class="org-constant">\n</span><span class="org-string">'</span>, end<span class="org-operator">+</span>1)
        <span class="org-keyword">if</span> raw[end<span class="org-operator">+</span>1] <span class="org-operator">!=</span> <span class="org-builtin">ord</span>(<span class="org-string">' '</span>): <span class="org-keyword">break</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Grab the value</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Also, drop the leading space on continuation lines</span>
    <span class="org-variable-name">value</span> <span class="org-operator">=</span> raw[spc<span class="org-operator">+</span>1:end].replace(b<span class="org-string">'</span><span class="org-constant">\n</span><span class="org-string"> '</span>, b<span class="org-string">'</span><span class="org-constant">\n</span><span class="org-string">'</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Don't overwrite existing data contents</span>
    <span class="org-keyword">if</span> key <span class="org-keyword">in</span> dct:
        <span class="org-keyword">if</span> <span class="org-builtin">type</span>(dct[key]) <span class="org-operator">==</span> <span class="org-builtin">list</span>:
            dct[key].append(value)
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">dct</span>[key] <span class="org-operator">=</span> [ dct[key], value ]
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">dct</span>[key]<span class="org-operator">=</span>value

    <span class="org-keyword">return</span> kvlm_parse(raw, start<span class="org-operator">=</span>end<span class="org-operator">+</span>1, dct<span class="org-operator">=</span>dct)
</pre>
</div>

<div class="note" id="org00b1b78">
<p>
<a id="org239f993"></a> <b>Object identity rules</b>
</p>

<p>
We use dictionaries (HashMaps) to store key/value associations, but we
rely on a specific feature of Python dictionaries: <b>they preserve
insertion order</b>.  It means that when we&rsquo;ll write back an object,
we&rsquo;ll iterate over the dictionary and get the fields back in the exact
order they were added.  This matters, because Git has <b>two strong
rules about object identity</b>:
</p>

<ol class="org-ol">
<li>The first rule is that <b>the same name will always refer to the
same object</b>.  We&rsquo;ve seen this one already, it&rsquo;s just a
consequence of the fact that an object&rsquo;s name is a hash of its
contents.</li>
<li>The second rule is subtly different: <b>the same object will always
be referred by the same name</b>.  This means that there shouldn&rsquo;t be
two equivalent objects under different names.  This is why fields
order matter: by modifying the <i>order</i> fields appear in a given
commit, eg by putting the <code>tree</code> after the <code>parent</code>, we&rsquo;d modify
the SHA-1 hash of the commit, and we&rsquo;d create two equivalent, but
numerically distinct, commit objects.</li>
</ol>

<p>
For example, when comparing trees, git will assume that two trees with
different names <i>are</i> different &#x2014; this is why we&rsquo;ll have to make
sure elements of the tree objects are properly sorted, so we don&rsquo;t
produce distinct but equivalent trees.
</p>

</div>

<p>
We&rsquo;re also going to need to write similar objects, so let&rsquo;s add a
<code>kvlm_serialize()</code> function to our toolkit.  This is very simple: we
write all fields first, then a newline, the message, and a final
newline.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">kvlm_serialize</span>(kvlm):
    <span class="org-variable-name">ret</span> <span class="org-operator">=</span> b<span class="org-string">''</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Output fields</span>
    <span class="org-keyword">for</span> k <span class="org-keyword">in</span> kvlm.keys():
        <span class="org-comment-delimiter"># </span><span class="org-comment">Skip the message itself</span>
        <span class="org-keyword">if</span> k <span class="org-operator">==</span> <span class="org-constant">None</span>: <span class="org-keyword">continue</span>
        <span class="org-variable-name">val</span> <span class="org-operator">=</span> kvlm[k]
        <span class="org-comment-delimiter"># </span><span class="org-comment">Normalize to a list</span>
        <span class="org-keyword">if</span> <span class="org-builtin">type</span>(val) <span class="org-operator">!=</span> <span class="org-builtin">list</span>:
            <span class="org-variable-name">val</span> <span class="org-operator">=</span> [ val ]

        <span class="org-keyword">for</span> v <span class="org-keyword">in</span> val:
            <span class="org-variable-name">ret</span> <span class="org-operator">+=</span> k <span class="org-operator">+</span> b<span class="org-string">' '</span> <span class="org-operator">+</span> (v.replace(b<span class="org-string">'</span><span class="org-constant">\n</span><span class="org-string">'</span>, b<span class="org-string">'</span><span class="org-constant">\n</span><span class="org-string"> '</span>)) <span class="org-operator">+</span> b<span class="org-string">'</span><span class="org-constant">\n</span><span class="org-string">'</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Append message</span>
    <span class="org-variable-name">ret</span> <span class="org-operator">+=</span> b<span class="org-string">'</span><span class="org-constant">\n</span><span class="org-string">'</span> <span class="org-operator">+</span> kvlm[<span class="org-constant">None</span>]

    <span class="org-keyword">return</span> ret
</pre>
</div>
</div>
</div>
<div id="outline-container-org5897046" class="outline-3">
<h3 id="org5897046"><span class="section-number-3">5.2.</span> The Commit object</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Now we have the parser, we can create the <code>GitCommit</code> class:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">GitCommit</span>(GitObject):
    <span class="org-variable-name">fmt</span><span class="org-operator">=</span>b<span class="org-string">'commit'</span>

    <span class="org-keyword">def</span> <span class="org-function-name">deserialize</span>(<span class="org-keyword">self</span>, data):
        <span class="org-keyword">self</span>.<span class="org-variable-name">kvlm</span> <span class="org-operator">=</span> kvlm_parse(data)

    <span class="org-keyword">def</span> <span class="org-function-name">serialize</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> kvlm_serialize(<span class="org-keyword">self</span>.kvlm)

    <span class="org-keyword">def</span> <span class="org-function-name">init</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">self</span>.<span class="org-variable-name">kvlm</span> <span class="org-operator">=</span> <span class="org-builtin">dict</span>()
</pre>
</div>
</div>
</div>
<div id="outline-container-cmd-log" class="outline-3">
<h3 id="cmd-log"><span class="section-number-3">5.3.</span> The log command</h3>
<div class="outline-text-3" id="text-cmd-log">
<p>
We&rsquo;ll implement a much, much simpler version of <code>log</code> than what Git
provides.  Most importantly, we won&rsquo;t deal with representing the log
<i>at all</i>.  Instead, we&rsquo;ll dump Graphviz data and let the user use
<code>dot</code> to render the actual log.  (If you don&rsquo;t know how to use
Graphviz, just paste the raw output into <a href="https://dreampuf.github.io/GraphvizOnline/">this site</a>.  If the link is
dead, lookup &ldquo;graphviz online&rdquo; in your favorite search engine)
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argsp</span> <span class="org-operator">=</span> argsubparsers.add_parser(<span class="org-string">"log"</span>, <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Display history of a given commit."</span>)
argsp.add_argument(<span class="org-string">"commit"</span>,
                   default<span class="org-operator">=</span><span class="org-string">"HEAD"</span>,
                   nargs<span class="org-operator">=</span><span class="org-string">"?"</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Commit to start at."</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cmd_log</span>(args):
    <span class="org-variable-name">repo</span> <span class="org-operator">=</span> repo_find()

    <span class="org-builtin">print</span>(<span class="org-string">"digraph wyaglog{"</span>)
    <span class="org-builtin">print</span>(<span class="org-string">"  node[shape=rect]"</span>)
    log_graphviz(repo, object_find(repo, args.commit), <span class="org-builtin">set</span>())
    <span class="org-builtin">print</span>(<span class="org-string">"}"</span>)

<span class="org-keyword">def</span> <span class="org-function-name">log_graphviz</span>(repo, sha, seen):

    <span class="org-keyword">if</span> sha <span class="org-keyword">in</span> seen:
        <span class="org-keyword">return</span>
    seen.add(sha)

    <span class="org-variable-name">commit</span> <span class="org-operator">=</span> object_read(repo, sha)
    <span class="org-variable-name">message</span> <span class="org-operator">=</span> commit.kvlm[<span class="org-constant">None</span>].decode(<span class="org-string">"utf8"</span>).strip()
    <span class="org-variable-name">message</span> <span class="org-operator">=</span> message.replace(<span class="org-string">"</span><span class="org-constant">\\</span><span class="org-string">"</span>, <span class="org-string">"</span><span class="org-constant">\\</span><span class="org-string">\\"</span>)
    <span class="org-variable-name">message</span> <span class="org-operator">=</span> message.replace(<span class="org-string">"\""</span>, <span class="org-string">"</span><span class="org-constant">\\</span><span class="org-string">\""</span>)

    <span class="org-keyword">if</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span> <span class="org-keyword">in</span> message: <span class="org-comment-delimiter"># </span><span class="org-comment">Keep only the first line</span>
        <span class="org-variable-name">message</span> <span class="org-operator">=</span> message[:message.index(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)]

    <span class="org-builtin">print</span>(f<span class="org-string">"  c_</span>{sha}<span class="org-string"> [label=\"</span>{sha[0:7]}<span class="org-string">: </span>{message}<span class="org-string">\"]"</span>)
    <span class="org-keyword">assert</span> commit.fmt<span class="org-operator">==</span>b<span class="org-string">'commit'</span>

    <span class="org-keyword">if</span> <span class="org-keyword">not</span> b<span class="org-string">'parent'</span> <span class="org-keyword">in</span> commit.kvlm.keys():
        <span class="org-comment-delimiter"># </span><span class="org-comment">Base case: the initial commit.</span>
        <span class="org-keyword">return</span>

    <span class="org-variable-name">parents</span> <span class="org-operator">=</span> commit.kvlm[b<span class="org-string">'parent'</span>]

    <span class="org-keyword">if</span> <span class="org-builtin">type</span>(parents) <span class="org-operator">!=</span> <span class="org-builtin">list</span>:
        <span class="org-variable-name">parents</span> <span class="org-operator">=</span> [ parents ]

    <span class="org-keyword">for</span> p <span class="org-keyword">in</span> parents:
        <span class="org-variable-name">p</span> <span class="org-operator">=</span> p.decode(<span class="org-string">"ascii"</span>)
        <span class="org-builtin">print</span> (f<span class="org-string">"  c_</span>{sha}<span class="org-string"> -&gt; c_</span>{p}<span class="org-string">;"</span>)
        log_graphviz(repo, p, seen)
</pre>
</div>

<p>
You can now use our log command like this:
</p>

<div class="org-src-container">
<pre class="src src-shell">wyag log e03158242ecab460f31b0d6ae1642880577ccbe8 &gt; log.dot
dot -O -Tpdf log.dot
</pre>
</div>
</div>
</div>
<div id="outline-container-commit-anatomy" class="outline-3">
<h3 id="commit-anatomy"><span class="section-number-3">5.4.</span> Anatomy of a commit</h3>
<div class="outline-text-3" id="text-commit-anatomy">
<p>
You may have noticed a few things right now.
</p>

<p>
First and foremost, we&rsquo;ve been playing with commits, browsing and
walking through commit objects, building a graph of commit history,
without ever touching a single file in the worktree or a blob.  We&rsquo;ve
done a lot with commits <i>without considering their contents</i>.  This is
important: work tree contents are just one part of a commit.  But a
commit is made of everything it holds: its contents, its authors,
<b>also its parents</b>.  If you remember that the ID (the SHA-1 hash) of a
commit is computed from the whole commit object, you&rsquo;ll understand
what it means that commits are immutable: if you change the author,
the parent commit or a single file, you&rsquo;ve actually created a new,
different object.  Each and every commit is bound to its place and its
relationship to the whole repository up to the very first commit.  To
put it otherwise, a given commit ID not only identifies some file
contents, but it also binds the commit to its whole history and to the
whole repository.
</p>

<p>
It&rsquo;s also worth noting that from the point of view of a commit, time
somehow runs backwards: we&rsquo;re used to considering the history of a
project from its humble beginnings as an evening distraction, starting
with a few lines of code, some initial commits, and progressing to its
present state (millions of lines of code, dozens of contributors,
whatever).  But each commit is completely unaware of its future, it&rsquo;s
only linked to the past.  Commits have &ldquo;memory&rdquo;, but no premonition.
</p>

<p>
So what makes a commit?  To sum it up:
</p>

<ul class="org-ul">
<li>A tree object, which we&rsquo;ll discuss now, that is, the contents of a
worktree, files and directories;</li>
<li>Zero, one or more parents;</li>
<li>An author identity (name and email), and a timestamp;</li>
<li>A committer identity (name and email), and a timestamp;</li>
<li>An optional PGP signature</li>
<li>A message;</li>
</ul>

<p>
All this hashed together in a unique SHA-1 identifier.
</p>

<div class="note" id="org71f257c">
<p>
<b>Wait, does that make Git a blockchain?</b>
</p>

<p>
Because of cryptocurrencies, blockchains are all the hype these
days.  And yes, <i>in a way</i>, Git is a blockchain: it&rsquo;s a sequence of
blocks (commits) tied together by cryptographic means in a way that
guarantee that each single element is associated to the whole
history of the structure.  Don&rsquo;t take the comparison too seriously,
though: we don&rsquo;t need a GitCoin.  Really, we don&rsquo;t.
</p>

</div>
</div>
</div>
</div>
<div id="outline-container-checkout" class="outline-2">
<h2 id="checkout"><span class="section-number-2">6.</span> Reading commit data: checkout</h2>
<div class="outline-text-2" id="text-checkout">
<p>
It&rsquo;s all well that commits hold a lot more than files and directories
in a given state, but that doesn&rsquo;t make them really useful.  It&rsquo;s
probably time to start implementing tree objects as well, so we&rsquo;ll be
able to checkout commits into the work tree.
</p>
</div>
<div id="outline-container-orgff23f86" class="outline-3">
<h3 id="orgff23f86"><span class="section-number-3">6.1.</span> What&rsquo;s in a tree?</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Informally, a tree describes the content of the work tree, that it, it
associates blobs to paths.  It&rsquo;s an array of three-element tuples made
of a file mode, a path (relative to the worktree) and a SHA-1.  A
typical tree contents may look like this:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Mode</th>
<th scope="col" class="org-left">SHA-1</th>
<th scope="col" class="org-left">Path</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>100644</code></td>
<td class="org-left"><code>894a44cc066a027465cd26d634948d56d13af9af</code></td>
<td class="org-left"><code>.gitignore</code></td>
</tr>

<tr>
<td class="org-left"><code>100644</code></td>
<td class="org-left"><code>94a9ed024d3859793618152ea559a168bbcbb5e2</code></td>
<td class="org-left"><code>LICENSE</code></td>
</tr>

<tr>
<td class="org-left"><code>100644</code></td>
<td class="org-left"><code>bab489c4f4600a38ce6dbfd652b90383a4aa3e45</code></td>
<td class="org-left"><code>README.md</code></td>
</tr>

<tr>
<td class="org-left"><code>100644</code></td>
<td class="org-left"><code>6d208e47659a2a10f5f8640e0155d9276a2130a9</code></td>
<td class="org-left"><code>src</code></td>
</tr>

<tr>
<td class="org-left"><code>040000</code></td>
<td class="org-left"><code>e7445b03aea61ec801b20d6ab62f076208b7d097</code></td>
<td class="org-left"><code>tests</code></td>
</tr>

<tr>
<td class="org-left"><code>040000</code></td>
<td class="org-left"><code>d5ec863f17f3a2e92aa8f6b66ac18f7b09fd1b38</code></td>
<td class="org-left"><code>main.c</code></td>
</tr>
</tbody>
</table>

<p>
Mode is just the file&rsquo;s <a href="https://en.wikipedia.org/wiki/File_system_permissions">mode</a>, path is its location.  The SHA-1 refers
to either a blob or another tree object.  If a blob, the path is a
file, if a tree, it&rsquo;s directory.  To instantiate this tree in the
filesystem, we would begin by loading the object associated to the
first path (<code>.gitignore</code>) and check its type.  Since it&rsquo;s a blob,
we&rsquo;ll just create a file called <code>.gitignore</code> with this blob&rsquo;s
contents; and same for <code>LICENSE</code> and <code>README.md</code>.  But the object
associated with <code>src</code> is not a blob, but another tree: we&rsquo;ll create
the directory <code>src</code> and repeat the same operation in that directory
with the new tree.
</p>

<div class="warning" id="org7b07bdd">
<p>
<b>A path is a single filesystem entry</b>
</p>

<p>
The path identifies exactly one file or directory.  Not two, not
three.  If you have five levels of nested directories, even if four
are empty save the next directory, you&rsquo;re going to need five tree
objects recursively referring to one another.  You cannot take the
shortcut of putting a full path in a single tree entry, like
<code>dir1/dir2/dir3/dir4/dir5</code>.
</p>

</div>
</div>
</div>
<div id="outline-container-orgdc9fa8c" class="outline-3">
<h3 id="orgdc9fa8c"><span class="section-number-3">6.2.</span> Parsing trees</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Unlike tags and commits, tree objects are binary objects, but their
format is actually quite simple.  A tree is the concatenation of
records of the format:
</p>

<pre class="example" id="org0b83bdc">
[mode] space [path] 0x00 [sha-1]
</pre>

<ul class="org-ul">
<li><code>[mode]</code> is up to six bytes and is an octal representation of a file
<b>mode</b>, stored in ASCII. For example, 100644 is encoded with byte
values 49 (ASCII &ldquo;1&rdquo;), 48 (ASCII &ldquo;0&rdquo;), 48, 54, 52, 52.  The first
two digits encode the file type (file, directory, symlink or
submodule), the last four the permissions.</li>
<li>It&rsquo;s followed by 0x20, an ASCII <b>space</b>;</li>
<li>Followed by the null-terminated (0x00) <b>path</b>;</li>
<li>Followed by the object&rsquo;s <b>SHA-1</b> in binary encoding, on 20 bytes.</li>
</ul>

<p>
The parser is going to be quite simple.  First, create a tiny object
wrapper for a single record (a leaf, a single path):
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">GitTreeLeaf</span> (<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, mode, path, sha):
        <span class="org-keyword">self</span>.<span class="org-variable-name">mode</span> <span class="org-operator">=</span> mode
        <span class="org-keyword">self</span>.<span class="org-variable-name">path</span> <span class="org-operator">=</span> path
        <span class="org-keyword">self</span>.<span class="org-variable-name">sha</span> <span class="org-operator">=</span> sha
</pre>
</div>

<p>
Because a tree object is just the repetition of the same fundamental
data structure, we write the parser in two functions.  First, a parser
to extract a single record, which returns parsed data and the position
it reached in input data:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">tree_parse_one</span>(raw, start<span class="org-operator">=</span>0):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Find the space terminator of the mode</span>
    <span class="org-variable-name">x</span> <span class="org-operator">=</span> raw.find(b<span class="org-string">' '</span>, start)
    <span class="org-keyword">assert</span> x<span class="org-operator">-</span>start <span class="org-operator">==</span> 5 <span class="org-keyword">or</span> x<span class="org-operator">-</span>start<span class="org-operator">==</span>6

    <span class="org-comment-delimiter"># </span><span class="org-comment">Read the mode</span>
    <span class="org-variable-name">mode</span> <span class="org-operator">=</span> raw[start:x]
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(mode) <span class="org-operator">==</span> 5:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Normalize to six bytes.</span>
        <span class="org-variable-name">mode</span> <span class="org-operator">=</span> b<span class="org-string">"0"</span> <span class="org-operator">+</span> mode

    <span class="org-comment-delimiter"># </span><span class="org-comment">Find the NULL terminator of the path</span>
    <span class="org-variable-name">y</span> <span class="org-operator">=</span> raw.find(b<span class="org-string">'</span><span class="org-constant">\x00</span><span class="org-string">'</span>, x)
    <span class="org-comment-delimiter"># </span><span class="org-comment">and read the path</span>
    <span class="org-variable-name">path</span> <span class="org-operator">=</span> raw[x<span class="org-operator">+</span>1:y]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Read the SHA&#8230;</span>
    <span class="org-variable-name">raw_sha</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>.from_bytes(raw[y<span class="org-operator">+</span>1:y<span class="org-operator">+</span>21], <span class="org-string">"big"</span>)
    <span class="org-comment-delimiter"># </span><span class="org-comment">and convert it into an hex string, padded to 40 chars</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">with zeros if needed.</span>
    <span class="org-variable-name">sha</span> <span class="org-operator">=</span> <span class="org-builtin">format</span>(raw_sha, <span class="org-string">"040x"</span>)
    <span class="org-keyword">return</span> y<span class="org-operator">+</span>21, GitTreeLeaf(mode, path.decode(<span class="org-string">"utf8"</span>), sha)
</pre>
</div>

<p>
And the &ldquo;real&rdquo; parser which just calls the previous one in a loop,
until input data is exhausted.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">tree_parse</span>(raw):
    <span class="org-variable-name">pos</span> <span class="org-operator">=</span> 0
    <span class="org-builtin">max</span> <span class="org-operator">=</span> <span class="org-builtin">len</span>(raw)
    <span class="org-variable-name">ret</span> <span class="org-operator">=</span> <span class="org-builtin">list</span>()
    <span class="org-keyword">while</span> pos <span class="org-operator">&lt;</span> <span class="org-builtin">max</span>:
        <span class="org-variable-name">pos</span>, <span class="org-variable-name">data</span> <span class="org-operator">=</span> tree_parse_one(raw, pos)
        ret.append(data)

    <span class="org-keyword">return</span> ret
</pre>
</div>

<p>
We&rsquo;ll finally need a serializer to write trees back.  Because we may
have added or modified entries, we need to sort them again.
Consistently sorting matters, because we need to respect git&rsquo;s
<a href="#org239f993">identity rules</a>, which says that no two equivalent object can have a
different hash &#x2014; but differently sorted trees with the same contents
<i>would</i> be equivalent (describing the same directory structure), and
still numerically distinct (different SHA-1 identifiers).  Incorrectly
sorted trees are invalid, but <i>git doesn&rsquo;t enforce that</i>.  I created
some invalid trees by accident writing wyag, and all I got was weird
bugs in <code>git status</code> (specifically, <code>status</code> would report an actually
clean worktree as fully modified).  We don&rsquo;t want that.
</p>

<p>
The ordering function is quite simple, with an unexpected twist.  are
Entries sorted by name, alphabetically, <i>but</i> directories (that is,
tree entries) are sorted with a final <code>/</code> added.  It matters, because
it means that if <code>whatever</code> names a regular file, it will sort
<i>before</i> <code>whatever.c</code>, but if <code>whatever</code> is a dir, it will sort
<i>after</i>, as <code>whatever/</code>. (I&rsquo;m not sure why git does that.  If you&rsquo;re
curious, see the function <code>base_name_compare</code> in <code>tree.c</code> in the git
source)
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Notice this isn't a comparison function, but a conversion function.</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Python's default sort doesn't accept a custom comparison function,</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">like in most languages, but a `key` arguments that returns a new</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">value, which is compared using the default rules.  So we just return</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">the leaf name, with an extra / if it's a directory.</span>
<span class="org-keyword">def</span> <span class="org-function-name">tree_leaf_sort_key</span>(leaf):
    <span class="org-keyword">if</span> leaf.mode.startswith(b<span class="org-string">"10"</span>):
        <span class="org-keyword">return</span> leaf.path
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> leaf.path <span class="org-operator">+</span> <span class="org-string">"/"</span>
</pre>
</div>

<p>
Then the serializer itself.  This one is very simple: we sort the
items using our newly created function as a transformer, then write
them in order.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">tree_serialize</span>(obj):
    obj.items.sort(key<span class="org-operator">=</span>tree_leaf_sort_key)
    <span class="org-variable-name">ret</span> <span class="org-operator">=</span> b<span class="org-string">''</span>
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> obj.items:
        <span class="org-variable-name">ret</span> <span class="org-operator">+=</span> i.mode
        <span class="org-variable-name">ret</span> <span class="org-operator">+=</span> b<span class="org-string">' '</span>
        <span class="org-variable-name">ret</span> <span class="org-operator">+=</span> i.path.encode(<span class="org-string">"utf8"</span>)
        <span class="org-variable-name">ret</span> <span class="org-operator">+=</span> b<span class="org-string">'</span><span class="org-constant">\x00</span><span class="org-string">'</span>
        <span class="org-variable-name">sha</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>(i.sha, 16)
        <span class="org-variable-name">ret</span> <span class="org-operator">+=</span> sha.to_bytes(20, byteorder<span class="org-operator">=</span><span class="org-string">"big"</span>)
    <span class="org-keyword">return</span> ret
</pre>
</div>

<p>
And now we just have to combine all that into a class:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">GitTree</span>(GitObject):
    <span class="org-variable-name">fmt</span><span class="org-operator">=</span>b<span class="org-string">'tree'</span>

    <span class="org-keyword">def</span> <span class="org-function-name">deserialize</span>(<span class="org-keyword">self</span>, data):
        <span class="org-keyword">self</span>.<span class="org-variable-name">items</span> <span class="org-operator">=</span> tree_parse(data)

    <span class="org-keyword">def</span> <span class="org-function-name">serialize</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> tree_serialize(<span class="org-keyword">self</span>)

    <span class="org-keyword">def</span> <span class="org-function-name">init</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">self</span>.<span class="org-variable-name">items</span> <span class="org-operator">=</span> <span class="org-builtin">list</span>()
</pre>
</div>
</div>
</div>
<div id="outline-container-cmd-ls-tree" class="outline-3">
<h3 id="cmd-ls-tree"><span class="section-number-3">6.3.</span> Showing trees: ls-tree</h3>
<div class="outline-text-3" id="text-cmd-ls-tree">
<p>
While we&rsquo;re at it, let&rsquo;s add the <code>ls-tree</code> command to wyag.  It&rsquo;s so
easy there&rsquo;s no reason not to.  <code>git ls-tree [-r] TREE</code> simply prints
the contents of a tree, recursively with the <code>-r</code> flag.  In recursive
mode, it doesn&rsquo;t show subtrees, just final objects with their full
paths.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org338249b"><span class="org-variable-name">argsp</span> <span class="org-operator">=</span> argsubparsers.add_parser(<span class="org-string">"ls-tree"</span>, <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Pretty-print a tree object."</span>)
argsp.add_argument(<span class="org-string">"-r"</span>,
                   dest<span class="org-operator">=</span><span class="org-string">"recursive"</span>,
                   action<span class="org-operator">=</span><span class="org-string">"store_true"</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Recurse into sub-trees"</span>)

argsp.add_argument(<span class="org-string">"tree"</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"A tree-ish object."</span>)

<span class="org-keyword">def</span> <span class="org-function-name">cmd_ls_tree</span>(args):
    <span class="org-variable-name">repo</span> <span class="org-operator">=</span> repo_find()
    ls_tree(repo, args.tree, args.recursive)

<span class="org-keyword">def</span> <span class="org-function-name">ls_tree</span>(repo, ref, recursive<span class="org-operator">=</span><span class="org-constant">None</span>, prefix<span class="org-operator">=</span><span class="org-string">""</span>):
    <span class="org-variable-name">sha</span> <span class="org-operator">=</span> object_find(repo, ref, fmt<span class="org-operator">=</span>b<span class="org-string">"tree"</span>)
    <span class="org-variable-name">obj</span> <span class="org-operator">=</span> object_read(repo, sha)
    <span class="org-keyword">for</span> item <span class="org-keyword">in</span> obj.items:
        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(item.mode) <span class="org-operator">==</span> 5:
            <span class="org-builtin">type</span> <span class="org-operator">=</span> item.mode[0:1]
        <span class="org-keyword">else</span>:
            <span class="org-builtin">type</span> <span class="org-operator">=</span> item.mode[0:2]

        <span class="org-keyword">match</span> <span class="org-builtin">type</span>: <span class="org-comment-delimiter"># </span><span class="org-comment">Determine the type.</span>
            <span class="org-keyword">case</span> b<span class="org-string">'04'</span>: <span class="org-builtin">type</span> <span class="org-operator">=</span> <span class="org-string">"tree"</span>
            <span class="org-keyword">case</span> b<span class="org-string">'10'</span>: <span class="org-builtin">type</span> <span class="org-operator">=</span> <span class="org-string">"blob"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">A regular file.</span>
            <span class="org-keyword">case</span> b<span class="org-string">'12'</span>: <span class="org-builtin">type</span> <span class="org-operator">=</span> <span class="org-string">"blob"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">A symlink. Blob contents is link target.</span>
            <span class="org-keyword">case</span> b<span class="org-string">'16'</span>: <span class="org-builtin">type</span> <span class="org-operator">=</span> <span class="org-string">"commit"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">A submodule</span>
            <span class="org-keyword">case</span> _: <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(f<span class="org-string">"Weird tree leaf mode </span>{item.mode}<span class="org-string">"</span>)

        <span class="org-keyword">if</span> <span class="org-keyword">not</span> (recursive <span class="org-keyword">and</span> <span class="org-builtin">type</span><span class="org-operator">==</span><span class="org-string">'tree'</span>): <span class="org-comment-delimiter"># </span><span class="org-comment">This is a leaf</span>
            <span class="org-builtin">print</span>(f<span class="org-string">"</span>{'0' <span class="org-operator">*</span> (6 <span class="org-operator">-</span> <span class="org-builtin">len</span>(item.mode)) <span class="org-operator">+</span> item.mode.decode(<span class="org-string">"</span><span class="org-builtin">ascii</span><span class="org-string">")} {type} {item.sha}\t{os.path.join(prefix, item.path)}"</span>)
        <span class="org-keyword">else</span>: <span class="org-comment-delimiter"># </span><span class="org-comment">This is a branch, recurse</span>
            ls_tree(repo, item.sha, recursive, os.path.join(prefix, item.path))
</pre>
</div>
</div>
</div>
<div id="outline-container-cmd-checkout" class="outline-3">
<h3 id="cmd-checkout"><span class="section-number-3">6.4.</span> The checkout command</h3>
<div class="outline-text-3" id="text-cmd-checkout">
<p>
<code>git checkout</code> simply instantiates a commit in the worktree.  We&rsquo;re
going to oversimplify the actual git command to make our
implementation clear and understandable.  We&rsquo;re also going to add a
few safeguards.  Here&rsquo;s how our version of checkout will work:
</p>

<ul class="org-ul">
<li>It will take two arguments: a commit, and a directory.  Git checkout
only needs a commit.</li>

<li>It will then instantiate the tree in the directory, <b>if and only if
the directory is empty</b>.  Git is full of safeguards to avoid
deleting data, which would be too complicated and unsafe to try to
reproduce in wyag.  Since the point of wyag is to demonstrate git,
not to produce a working implementation, this limitation is
acceptable.</li>
</ul>

<p>
Let&rsquo;s get started.  As usual, we need a subparser:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argsp</span> <span class="org-operator">=</span> argsubparsers.add_parser(<span class="org-string">"checkout"</span>, <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Checkout a commit inside of a directory."</span>)

argsp.add_argument(<span class="org-string">"commit"</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"The commit or tree to checkout."</span>)

argsp.add_argument(<span class="org-string">"path"</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"The EMPTY directory to checkout on."</span>)
</pre>
</div>

<p>
A wrapper function:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cmd_checkout</span>(args):
    <span class="org-variable-name">repo</span> <span class="org-operator">=</span> repo_find()

    <span class="org-variable-name">obj</span> <span class="org-operator">=</span> object_read(repo, object_find(repo, args.commit))

    <span class="org-comment-delimiter"># </span><span class="org-comment">If the object is a commit, we grab its tree</span>
    <span class="org-keyword">if</span> obj.fmt <span class="org-operator">==</span> b<span class="org-string">'commit'</span>:
        <span class="org-variable-name">obj</span> <span class="org-operator">=</span> object_read(repo, obj.kvlm[b<span class="org-string">'tree'</span>].decode(<span class="org-string">"ascii"</span>))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Verify that path is an empty directory</span>
    <span class="org-keyword">if</span> os.path.exists(args.path):
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> os.path.isdir(args.path):
            <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(f<span class="org-string">"Not a directory </span>{args.path}<span class="org-string">!"</span>)
        <span class="org-keyword">if</span> os.listdir(args.path):
            <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(f<span class="org-string">"Not empty </span>{args.path}<span class="org-string">!"</span>)
    <span class="org-keyword">else</span>:
        os.makedirs(args.path)

    tree_checkout(repo, obj, os.path.realpath(args.path))
</pre>
</div>

<p>
And a function to do the actual work:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">tree_checkout</span>(repo, tree, path):
    <span class="org-keyword">for</span> item <span class="org-keyword">in</span> tree.items:
        <span class="org-variable-name">obj</span> <span class="org-operator">=</span> object_read(repo, item.sha)
        <span class="org-variable-name">dest</span> <span class="org-operator">=</span> os.path.join(path, item.path)

        <span class="org-keyword">if</span> obj.fmt <span class="org-operator">==</span> b<span class="org-string">'tree'</span>:
            os.mkdir(dest)
            tree_checkout(repo, obj, dest)
        <span class="org-keyword">elif</span> obj.fmt <span class="org-operator">==</span> b<span class="org-string">'blob'</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">@TODO Support symlinks (identified by mode 12****)</span>
            <span class="org-keyword">with</span> <span class="org-builtin">open</span>(dest, <span class="org-string">'wb'</span>) <span class="org-keyword">as</span> f:
                f.write(obj.blobdata)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6d10996" class="outline-2">
<h2 id="org6d10996"><span class="section-number-2">7.</span> Refs, tags and branches</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-cmd-show-ref" class="outline-3">
<h3 id="cmd-show-ref"><span class="section-number-3">7.1.</span> What a ref is, and the show-ref command</h3>
<div class="outline-text-3" id="text-cmd-show-ref">
<p>
As of now, the only way we can refer to objects is by their full
hexadecimal identifier.  In git, we actually rarely see those, except
to talk about a specific commit.  But in general, we&rsquo;re talking about
HEAD, about some branch called names like <code>main</code> or
<code>feature/more-bombs</code>, and so on.  This is handled by a simple
mechanism called references.
</p>

<p>
Git references, or refs, are probably the most simple type of things
git holds.  They live in subdirectories of <code>.git/refs</code>, and are text
files containing a hexadecimal representation of an object&rsquo;s hash,
encoded in ASCII.  They&rsquo;re actually as simple as this:
</p>

<pre class="example" id="orgfe8ce6e">
6071c08bcb4757d8c89a30d9755d2466cef8c1de
</pre>

<p>
Refs can also refer to another reference, and thus only indirectly to
an object, in which case they look like this:
</p>

<pre class="example" id="org5e93ac9">
ref: refs/remotes/origin/master
</pre>

<div class="note" id="org92ed826">
<p>
<b>Direct and indirect references</b>
</p>

<p>
From now on, I will call a reference of the form <code>ref:
  path/to/other/ref</code> an <b>indirect</b> reference, and a ref with a SHA-1
object ID a <b>direct reference</b>.
</p>

</div>

<p>
This section will describe the uses of refs.  For now, all that matter
is this:
</p>

<ul class="org-ul">
<li>they&rsquo;re text files, in the <code>.git/refs</code> hierarchy;</li>
<li>they hold the SHA-1 identifier of an object, or a reference to
another reference, ultimately to a SHA-1 (no loops!)</li>
</ul>

<p>
To work with refs, we&rsquo;re first going to need a simple recursive solver
that will take a ref name, follow eventual recursive references (refs
whose content begin with <code>ref:</code>, as exemplified above) and return a
SHA-1 identifier:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">ref_resolve</span>(repo, ref):
    <span class="org-variable-name">path</span> <span class="org-operator">=</span> repo_file(repo, ref)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Sometimes, an indirect reference may be broken.  This is normal</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">in one specific case: we're looking for HEAD on a new repository</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">with no commits.  In that case, .git/HEAD points to "ref:</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">refs/heads/main", but .git/refs/heads/main doesn't exist yet</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">(since there's no commit for it to refer to).</span>
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> os.path.isfile(path):
        <span class="org-keyword">return</span> <span class="org-constant">None</span>

    <span class="org-keyword">with</span> <span class="org-builtin">open</span>(path, <span class="org-string">'r'</span>) <span class="org-keyword">as</span> fp:
        <span class="org-variable-name">data</span> <span class="org-operator">=</span> fp.read()[:<span class="org-operator">-</span>1]
        <span class="org-comment-delimiter"># </span><span class="org-comment">Drop final \n ^^^^^</span>
    <span class="org-keyword">if</span> data.startswith(<span class="org-string">"ref: "</span>):
        <span class="org-keyword">return</span> ref_resolve(repo, data[5:])
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> data
</pre>
</div>

<p>
Let&rsquo;s create two small functions, and implement the <code>show-ref</code>
command &#x2014; it just lists all references in a repository.  First, a
stupid recursive function to collect refs and return them as a dict:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">ref_list</span>(repo, path<span class="org-operator">=</span><span class="org-constant">None</span>):
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> path:
        <span class="org-variable-name">path</span> <span class="org-operator">=</span> repo_dir(repo, <span class="org-string">"refs"</span>)
    <span class="org-variable-name">ret</span> <span class="org-operator">=</span> <span class="org-builtin">dict</span>()
    <span class="org-comment-delimiter"># </span><span class="org-comment">Git shows refs sorted.  To do the same, we sort the output of</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">listdir</span>
    <span class="org-keyword">for</span> f <span class="org-keyword">in</span> <span class="org-builtin">sorted</span>(os.listdir(path)):
        <span class="org-variable-name">can</span> <span class="org-operator">=</span> os.path.join(path, f)
        <span class="org-keyword">if</span> os.path.isdir(can):
            <span class="org-variable-name">ret</span>[f] <span class="org-operator">=</span> ref_list(repo, can)
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">ret</span>[f] <span class="org-operator">=</span> ref_resolve(repo, can)

    <span class="org-keyword">return</span> ret
</pre>
</div>

<p>
And, as usual, a subparser, a bridge, and a (recursive) worker function:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argsp</span> <span class="org-operator">=</span> argsubparsers.add_parser(<span class="org-string">"show-ref"</span>, <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"List references."</span>)

<span class="org-keyword">def</span> <span class="org-function-name">cmd_show_ref</span>(args):
    <span class="org-variable-name">repo</span> <span class="org-operator">=</span> repo_find()
    <span class="org-variable-name">refs</span> <span class="org-operator">=</span> ref_list(repo)
    show_ref(repo, refs, prefix<span class="org-operator">=</span><span class="org-string">"refs"</span>)

<span class="org-keyword">def</span> <span class="org-function-name">show_ref</span>(repo, refs, with_hash<span class="org-operator">=</span><span class="org-constant">True</span>, prefix<span class="org-operator">=</span><span class="org-string">""</span>):
    <span class="org-keyword">if</span> prefix:
        <span class="org-variable-name">prefix</span> <span class="org-operator">=</span> prefix <span class="org-operator">+</span> <span class="org-string">'/'</span>
    <span class="org-keyword">for</span> k, v <span class="org-keyword">in</span> refs.items():
        <span class="org-keyword">if</span> <span class="org-builtin">type</span>(v) <span class="org-operator">==</span> <span class="org-builtin">str</span> <span class="org-keyword">and</span> with_hash:
            <span class="org-builtin">print</span> (f<span class="org-string">"</span>{v}<span class="org-string"> </span>{prefix}{k}<span class="org-string">"</span>)
        <span class="org-keyword">elif</span> <span class="org-builtin">type</span>(v) <span class="org-operator">==</span> <span class="org-builtin">str</span>:
            <span class="org-builtin">print</span> (f<span class="org-string">"</span>{prefix}{k}<span class="org-string">"</span>)
        <span class="org-keyword">else</span>:
            show_ref(repo, v, with_hash<span class="org-operator">=</span>with_hash, prefix<span class="org-operator">=</span>f<span class="org-string">"</span>{prefix}{k}<span class="org-string">"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-tags" class="outline-3">
<h3 id="tags"><span class="section-number-3">7.2.</span> Tags as references</h3>
<div class="outline-text-3" id="text-tags">
<p>
The most simple use of refs is tags.  A tag is just a user-defined
name for an object, often a commit.  A very common use of tags is
identifying software releases: You&rsquo;ve just merged the last commit of,
say, version 12.78.52 of your program, so your most recent commit
(let&rsquo;s call it <code>6071c08</code>) <i>is</i> your version 12.78.52.  To make this
association explicit, all you have to do is:
</p>

<div class="org-src-container">
<pre class="src src-shell">git tag v12.78.52 6071c08
<span class="org-comment-delimiter"># </span><span class="org-comment">the object hash ^here^^ is optional and defaults to HEAD.</span>
</pre>
</div>

<p>
This creates a new tag, called <code>v12.78.52</code>, pointing at <code>6071c08</code>.
Tagging is like aliasing: a tag introduces a new way to refer to an
existing object.  After the tag is created, the name <code>v12.78.52</code> refers
to <code>6071c08</code>.  For example, these two commands are now perfectly
equivalent:
</p>

<div class="org-src-container">
<pre class="src src-shell">git checkout v12.78.52
git checkout 6071c08
</pre>
</div>

<div class="note" id="orgb09c8ee">
<p>
Versions are a common use of tags, but like almost everything in
Git, tags have no predefined semantics: they mean whatever you want
them to mean, and can point to whichever object you want, you can
even tag <i>blobs</i>!
</p>

</div>
</div>
</div>
<div id="outline-container-GitTag" class="outline-3">
<h3 id="GitTag"><span class="section-number-3">7.3.</span> Lightweight tags and tag objects, and parsing the latter</h3>
<div class="outline-text-3" id="text-GitTag">
<p>
You&rsquo;ve probably guessed already that tags are actually refs.  They
live in the <code>.git/refs/tags/</code> hierarchy.  The only point worth noting is
that they come in two flavors: lightweight tags and tags objects.
</p>

<dl class="org-dl">
<dt>&ldquo;Lightweight&rdquo; tags</dt><dd>are just regular refs to a commit, a tree or
a blob.</dd>

<dt>Tag objects</dt><dd>are regular refs pointing to an object of type <code>tag</code>.
Unlike lightweight tags, tag objects have an author, a date, an
optional PGP signature and an optional annotation.  Their format is
the same as a commit object.</dd>
</dl>

<p>
We don&rsquo;t even need to implement tag objects, we can reuse <code>GitCommit</code>
and just change the <code>fmt</code> field:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">GitTag</span>(GitCommit):
    <span class="org-variable-name">fmt</span> <span class="org-operator">=</span> b<span class="org-string">'tag'</span>
</pre>
</div>

<p>
And now we support tags.
</p>
</div>
</div>
<div id="outline-container-cmd-tag" class="outline-3">
<h3 id="cmd-tag"><span class="section-number-3">7.4.</span> The tag command</h3>
<div class="outline-text-3" id="text-cmd-tag">
<p>
Let&rsquo;s add the <code>tag</code> command.  In Git, it does two things: it creates a
new tag or list existing tags (by default).  So you can invoke it with:
</p>

<div class="org-src-container">
<pre class="src src-shell">git tag                  <span class="org-comment-delimiter"># </span><span class="org-comment">List all tags</span>
git tag NAME [OBJECT]    <span class="org-comment-delimiter"># </span><span class="org-comment">create a new *lightweight* tag NAME, pointing</span>
                         <span class="org-comment-delimiter"># </span><span class="org-comment">at HEAD (default) or OBJECT</span>
git tag -a NAME [OBJECT] <span class="org-comment-delimiter"># </span><span class="org-comment">create a new tag *object* NAME, pointing at</span>
                         <span class="org-comment-delimiter"># </span><span class="org-comment">HEAD (default) or OBJECT</span>
</pre>
</div>

<p>
This translates to argparse as follows.  Notice we ignore the mutual
exclusion between <code>--list</code> and <code>[-a] name [object]</code>, which seems too
complicated for argparse.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argsp</span> <span class="org-operator">=</span> argsubparsers.add_parser(
    <span class="org-string">"tag"</span>,
    <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"List and create tags"</span>)

argsp.add_argument(<span class="org-string">"-a"</span>,
                   action<span class="org-operator">=</span><span class="org-string">"store_true"</span>,
                   dest<span class="org-operator">=</span><span class="org-string">"create_tag_object"</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Whether to create a tag object"</span>)

argsp.add_argument(<span class="org-string">"name"</span>,
                   nargs<span class="org-operator">=</span><span class="org-string">"?"</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"The new tag's name"</span>)

argsp.add_argument(<span class="org-string">"object"</span>,
                   default<span class="org-operator">=</span><span class="org-string">"HEAD"</span>,
                   nargs<span class="org-operator">=</span><span class="org-string">"?"</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"The object the new tag will point to"</span>)
</pre>
</div>

<p>
The <code>cmd_tag</code> function will dispatch behavior (list or create) depending
on whether or not <code>name</code> is provided.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cmd_tag</span>(args):
    <span class="org-variable-name">repo</span> <span class="org-operator">=</span> repo_find()

    <span class="org-keyword">if</span> args.name:
        tag_create(repo,
                   args.name,
                   args.<span class="org-builtin">object</span>,
                   create_tag_object <span class="org-operator">=</span> args.create_tag_object)
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">refs</span> <span class="org-operator">=</span> ref_list(repo)
        show_ref(repo, refs[<span class="org-string">"tags"</span>], with_hash<span class="org-operator">=</span><span class="org-constant">False</span>)
</pre>
</div>

<p>
And we just need one more function to actually create the tag:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">tag_create</span>(repo, name, ref, create_tag_object<span class="org-operator">=</span><span class="org-constant">False</span>):
    <span class="org-comment-delimiter"># </span><span class="org-comment">get the GitObject from the object reference</span>
    <span class="org-variable-name">sha</span> <span class="org-operator">=</span> object_find(repo, ref)

    <span class="org-keyword">if</span> create_tag_object:
        <span class="org-comment-delimiter"># </span><span class="org-comment">create tag object (commit)</span>
        <span class="org-variable-name">tag</span> <span class="org-operator">=</span> GitTag()
        tag.<span class="org-variable-name">kvlm</span> <span class="org-operator">=</span> <span class="org-builtin">dict</span>()
        tag.<span class="org-variable-name">kvlm</span>[b<span class="org-string">'object'</span>] <span class="org-operator">=</span> sha.encode()
        tag.<span class="org-variable-name">kvlm</span>[b<span class="org-string">'type'</span>] <span class="org-operator">=</span> b<span class="org-string">'commit'</span>
        tag.<span class="org-variable-name">kvlm</span>[b<span class="org-string">'tag'</span>] <span class="org-operator">=</span> name.encode()
        <span class="org-comment-delimiter"># </span><span class="org-comment">Feel free to let the user give their name!</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Notice you can fix this after commit, read on!</span>
        tag.<span class="org-variable-name">kvlm</span>[b<span class="org-string">'tagger'</span>] <span class="org-operator">=</span> b<span class="org-string">'Wyag <a href="mailto:wyag%40example.com">&lt;wyag@example.com&gt;</a>'</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">&#8230;and a tag message!</span>
        tag.<span class="org-variable-name">kvlm</span>[<span class="org-constant">None</span>] <span class="org-operator">=</span> b<span class="org-string">"A tag generated by wyag, which won't let you customize the message!</span><span class="org-constant">\n</span><span class="org-string">"</span>
        <span class="org-variable-name">tag_sha</span> <span class="org-operator">=</span> object_write(tag, repo)
        <span class="org-comment-delimiter"># </span><span class="org-comment">create reference</span>
        ref_create(repo, <span class="org-string">"tags/"</span> <span class="org-operator">+</span> name, tag_sha)
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">create lightweight tag (ref)</span>
        ref_create(repo, <span class="org-string">"tags/"</span> <span class="org-operator">+</span> name, sha)

<span class="org-keyword">def</span> <span class="org-function-name">ref_create</span>(repo, ref_name, sha):
    <span class="org-keyword">with</span> <span class="org-builtin">open</span>(repo_file(repo, <span class="org-string">"refs/"</span> <span class="org-operator">+</span> ref_name), <span class="org-string">'w'</span>) <span class="org-keyword">as</span> fp:
        fp.write(sha <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-branches" class="outline-3">
<h3 id="branches"><span class="section-number-3">7.5.</span> What&rsquo;s a branch?</h3>
<div class="outline-text-3" id="text-branches">
<p>
Tags are done.  Now for another big chunk: branches.
</p>

<p>
It&rsquo;s time to address the elephant in the room: like most Git users,
wyag still doesn&rsquo;t have any idea what a branch is.  It currently
treats a repository as a bunch of disorganized objects, some of them
commits, and has no representation whatsoever of the fact that commits
are grouped in branches, and that at every point in time there&rsquo;s a
commit that&rsquo;s <code>HEAD</code>, <i>ie</i>, the <b>head</b> commit (or &ldquo;tip&rdquo;) of the
<b>active</b> branch.
</p>

<p>
So, what&rsquo;s a branch?  The answer is actually surprisingly simple, but
it may also end up being simply surprising: <b>a branch is a reference
to a commit</b>.  You could even say that a branch is a kind of a name
for a commit.  In this regard, a branch is exactly the same thing as a
tag.  Tags are refs that live in <code>.git/refs/tags</code>, branches are refs
that live in <code>.git/refs/heads</code>.
</p>

<p>
There are, of course, differences between a branch and a tag:
</p>

<ol class="org-ol">
<li>Branches are references to a <i>commit</i>, tags can refer to any object;</li>
<li>Most importantly, the branch ref is updated at each commit.  This means
that whenever you commit, Git actually does this:
<ol class="org-ol">
<li>a new commit object is created, with the current branch&rsquo;s
(commit!) ID as its parent;</li>
<li>the commit object is hashed and stored;</li>
<li>the branch ref is updated to refer to the new commit&rsquo;s hash.</li>
</ol></li>
</ol>

<p>
That&rsquo;s all.
</p>

<p>
But what about the <b>current</b> branch?  It&rsquo;s actually even easier.  It&rsquo;s a
ref file outside of the <code>refs</code> hierarchy, in <code>.git/HEAD</code>, which is an
<b>indirect</b> ref (that is, it is of the form <code>ref: path/to/other/ref</code>, and
not a simple hash).
</p>

<div class="note" id="org98c3e0a">
<p>
<b>Detached HEAD</b>
</p>

<p>
When you just checkout a random commit, git will warn you it&rsquo;s in
&ldquo;detached HEAD state&rdquo;.  This means you&rsquo;re not on any branch anymore.
In this case, <code>.git/HEAD</code> is a <b>direct</b> reference: it contains a
SHA-1.
</p>

</div>
</div>
</div>
<div id="outline-container-object_find" class="outline-3">
<h3 id="object_find"><span class="section-number-3">7.6.</span> Referring to objects: the <code>object_find</code> function</h3>
<div class="outline-text-3" id="text-object_find">
</div>
<div id="outline-container-org753766b" class="outline-4">
<h4 id="org753766b"><span class="section-number-4">7.6.1.</span> Resolving names</h4>
<div class="outline-text-4" id="text-7-6-1">
<p>
Remember when we&rsquo;ve created <a href="#orgdffd24d">the stupid <code>object_find</code> function</a> that would
take four arguments, return the second unmodified and ignore the other
three?  It&rsquo;s time to replace it by something more useful.  We&rsquo;re going
to implement a small, but usable, subset of the actual Git name
resolution algorithm.  The new <code>object_find()</code> will work in two steps:
first, given a name, it will return a complete sha-1 hash.  For
example, with <code>HEAD</code>, it will return the hash of the head commit of the
current branch, etc.  More precisely, this name resolution function
will work like this:
</p>

<ul class="org-ul">
<li>If <code>name</code> is <code>HEAD</code>, it will just resolve <code>.git/HEAD</code>;</li>
<li>If <code>name</code> is a full hash, this hash is returned unmodified.</li>
<li>If <code>name</code> looks like a short hash, it will collect objects whose full
hash begin with this short hash.</li>
<li>At last, it will resolve tags and branches matching name.</li>
</ul>

<p>
Notice how the last two steps <i>collect</i> values: the first two are
absolute references, so we can safely return a result.  But short
hashes or branch names can be ambiguous, we want to enumerate all
possible meanings of the name and raise an error if we&rsquo;ve found more
than 1.
</p>

<div class="info" id="org79080c1">
<p>
<b>Short hashes</b>
</p>

<p>
For convenience, Git allows to refer to hashes by a prefix of their
name.  For example, <code>5bd254aa973646fa16f66d702a5826ea14a3eb45</code> can
be referred to as <code>5bd254</code>.  This is called a &ldquo;short hash&rdquo;.
</p>

</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">object_resolve</span>(repo, name):
    <span class="org-doc">"""Resolve name to an object hash in repo.</span>

<span class="org-doc">This function is aware of:</span>

<span class="org-doc"> - the HEAD literal</span>
<span class="org-doc">    - short and long hashes</span>
<span class="org-doc">    - tags</span>
<span class="org-doc">    - branches</span>
<span class="org-doc">    - remote branches"""</span>
    <span class="org-variable-name">candidates</span> <span class="org-operator">=</span> <span class="org-builtin">list</span>()
    <span class="org-variable-name">hashRE</span> <span class="org-operator">=</span> re.<span class="org-builtin">compile</span>(r<span class="org-string">"^[0-9A-Fa-f]{4,40}$"</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Empty string?  Abort.</span>
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> name.strip():
        <span class="org-keyword">return</span> <span class="org-constant">None</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Head is nonambiguous</span>
    <span class="org-keyword">if</span> name <span class="org-operator">==</span> <span class="org-string">"HEAD"</span>:
        <span class="org-keyword">return</span> [ ref_resolve(repo, <span class="org-string">"HEAD"</span>) ]

    <span class="org-comment-delimiter"># </span><span class="org-comment">If it's a hex string, try for a hash.</span>
    <span class="org-keyword">if</span> hashRE.<span class="org-keyword">match</span>(name):
        <span class="org-comment-delimiter"># </span><span class="org-comment">This may be a hash, either small or full.  4 seems to be the</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">minimal length for git to consider something a short hash.</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">This limit is documented in man git-rev-parse</span>
        <span class="org-variable-name">name</span> <span class="org-operator">=</span> name.lower()
        <span class="org-variable-name">prefix</span> <span class="org-operator">=</span> name[0:2]
        <span class="org-variable-name">path</span> <span class="org-operator">=</span> repo_dir(repo, <span class="org-string">"objects"</span>, prefix, mkdir<span class="org-operator">=</span><span class="org-constant">False</span>)
        <span class="org-keyword">if</span> path:
            <span class="org-variable-name">rem</span> <span class="org-operator">=</span> name[2:]
            <span class="org-keyword">for</span> f <span class="org-keyword">in</span> os.listdir(path):
                <span class="org-keyword">if</span> f.startswith(rem):
                    <span class="org-comment-delimiter"># </span><span class="org-comment">Notice a string startswith() itself, so this</span>
                    <span class="org-comment-delimiter"># </span><span class="org-comment">works for full hashes.</span>
                    candidates.append(prefix <span class="org-operator">+</span> f)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Try for references.</span>
    <span class="org-variable-name">as_tag</span> <span class="org-operator">=</span> ref_resolve(repo, <span class="org-string">"refs/tags/"</span> <span class="org-operator">+</span> name)
    <span class="org-keyword">if</span> as_tag: <span class="org-comment-delimiter"># </span><span class="org-comment">Did we find a tag?</span>
        candidates.append(as_tag)

    <span class="org-variable-name">as_branch</span> <span class="org-operator">=</span> ref_resolve(repo, <span class="org-string">"refs/heads/"</span> <span class="org-operator">+</span> name)
    <span class="org-keyword">if</span> as_branch: <span class="org-comment-delimiter"># </span><span class="org-comment">Did we find a branch?</span>
        candidates.append(as_branch)

    <span class="org-variable-name">as_remote_branch</span> <span class="org-operator">=</span> ref_resolve(repo, <span class="org-string">"refs/remotes/"</span> <span class="org-operator">+</span> name)
    <span class="org-keyword">if</span> as_remote_branch: <span class="org-comment-delimiter"># </span><span class="org-comment">Did we find a remote branch?</span>
        candidates.append(as_remote_branch)

    <span class="org-keyword">return</span> candidates
</pre>
</div>

<p>
The second step is to follow the object we found to an object of the
required type, if a type argument was provided.  Since we only need to
handle trivial cases, this is a very simple iterative process:
</p>

<ul class="org-ul">
<li>If we have a tag and <code>fmt</code> is anything else, we follow the tag.</li>
<li>If we have a commit and <code>fmt</code> is tree, we return this commit&rsquo;s tree
object</li>
<li>In all other situations, we bail out: nothing else makes sense.</li>
</ul>

<p>
(The process is iterative because it may take an undefined number of
steps, since tags themselves can be tagged)
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">object_find</span>(repo, name, fmt<span class="org-operator">=</span><span class="org-constant">None</span>, follow<span class="org-operator">=</span><span class="org-constant">True</span>):
    <span class="org-variable-name">sha</span> <span class="org-operator">=</span> object_resolve(repo, name)

    <span class="org-keyword">if</span> <span class="org-keyword">not</span> sha:
        <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(f<span class="org-string">"No such reference </span>{name}<span class="org-string">."</span>)

    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(sha) <span class="org-operator">&gt;</span> 1:
        <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(<span class="org-string">"Ambiguous reference {name}: Candidates are:</span><span class="org-constant">\n</span><span class="org-string"> - {'</span><span class="org-constant">\n</span><span class="org-string"> - '.join(sha)}."</span>)

    <span class="org-variable-name">sha</span> <span class="org-operator">=</span> sha[0]

    <span class="org-keyword">if</span> <span class="org-keyword">not</span> fmt:
        <span class="org-keyword">return</span> sha

    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-variable-name">obj</span> <span class="org-operator">=</span> object_read(repo, sha)
        <span class="org-comment-delimiter">#     </span><span class="org-comment">^^^^^^^^^^^ &lt; this is a bit agressive: we're reading</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">the full object just to get its type.  And we're doing</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">that in a loop, albeit normally short.  Don't expect</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">high performance here.</span>

        <span class="org-keyword">if</span> obj.fmt <span class="org-operator">==</span> fmt:
            <span class="org-keyword">return</span> sha

        <span class="org-keyword">if</span> <span class="org-keyword">not</span> follow:
            <span class="org-keyword">return</span> <span class="org-constant">None</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Follow tags</span>
        <span class="org-keyword">if</span> obj.fmt <span class="org-operator">==</span> b<span class="org-string">'tag'</span>:
            <span class="org-variable-name">sha</span> <span class="org-operator">=</span> obj.kvlm[b<span class="org-string">'object'</span>].decode(<span class="org-string">"ascii"</span>)
        <span class="org-keyword">elif</span> obj.fmt <span class="org-operator">==</span> b<span class="org-string">'commit'</span> <span class="org-keyword">and</span> fmt <span class="org-operator">==</span> b<span class="org-string">'tree'</span>:
            <span class="org-variable-name">sha</span> <span class="org-operator">=</span> obj.kvlm[b<span class="org-string">'tree'</span>].decode(<span class="org-string">"ascii"</span>)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> <span class="org-constant">None</span>
</pre>
</div>

<p>
With the new <code>object_find()</code>, the CLI wyag becomes a bit more usable.  You can now do things like:
</p>

<pre class="example" id="org1569aa7">
$ wyag checkout v3.11 # A tag
$ wyag checkout feature/explosions # A branch
$ wyag ls-tree -r HEAD # The active branch or commit.  There's also a
                       # follow here: HEAD is actually a commit.
$ wyag cat-file blob e0695f # A short hash
$ wyag cat-file tree master # A branch, as a tree (another "follow")
</pre>
</div>
</div>
<div id="outline-container-cmd-rev-parse" class="outline-4">
<h4 id="cmd-rev-parse"><span class="section-number-4">7.6.2.</span> The rev-parse command</h4>
<div class="outline-text-4" id="text-cmd-rev-parse">
<p>
Let&rsquo;s implement <code>wyag rev-parse</code>.  The <code>git rev-parse</code> commands does a
lot, but one of its use cases, the one we&rsquo;re going to clone, is
solving references.  For the purpose of further testing the &ldquo;follow&rdquo;
feature of <code>object_find</code>, we&rsquo;ll add an optional <code>wyag-type</code> argument
to its interface.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argsp</span> <span class="org-operator">=</span> argsubparsers.add_parser(
    <span class="org-string">"rev-parse"</span>,
    <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Parse revision (or other objects) identifiers"</span>)

argsp.add_argument(<span class="org-string">"--wyag-type"</span>,
                   metavar<span class="org-operator">=</span><span class="org-string">"type"</span>,
                   dest<span class="org-operator">=</span><span class="org-string">"type"</span>,
                   choices<span class="org-operator">=</span>[<span class="org-string">"blob"</span>, <span class="org-string">"commit"</span>, <span class="org-string">"tag"</span>, <span class="org-string">"tree"</span>],
                   default<span class="org-operator">=</span><span class="org-constant">None</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Specify the expected type"</span>)

argsp.add_argument(<span class="org-string">"name"</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"The name to parse"</span>)
</pre>
</div>

<p>
The bridge does all the job:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cmd_rev_parse</span>(args):
    <span class="org-keyword">if</span> args.<span class="org-builtin">type</span>:
        <span class="org-variable-name">fmt</span> <span class="org-operator">=</span> args.<span class="org-builtin">type</span>.encode()
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">fmt</span> <span class="org-operator">=</span> <span class="org-constant">None</span>

    <span class="org-variable-name">repo</span> <span class="org-operator">=</span> repo_find()

    <span class="org-builtin">print</span> (object_find(repo, args.name, fmt, follow<span class="org-operator">=</span><span class="org-constant">True</span>))
</pre>
</div>

<p>
And it works:
</p>

<pre class="example" id="org1d433c7">
$ wyag rev-parse --wyag-type commit HEAD
6c22393f5e3830d15395fd8d2f8b0cf8eb40dd58
$ wyag rev-parse --wyag-type tree HEAD
11d33fad71dbac72840aff1447e0d080c7484361
$ wyag rev-parse --wyag-type tag HEAD
None
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-staging-area" class="outline-2">
<h2 id="staging-area"><span class="section-number-2">8.</span> Working with the staging area and the index file</h2>
<div class="outline-text-2" id="text-staging-area">
</div>
<div id="outline-container-staging-intro" class="outline-3">
<h3 id="staging-intro"><span class="section-number-3">8.1.</span> What&rsquo;s the index file?</h3>
<div class="outline-text-3" id="text-staging-intro">
<p>
This final step will bring us to where commits happen (although
actually creating them is for the next section!)
</p>

<p>
You probably know that to commit in Git, you first &ldquo;stage&rdquo; some
changes, using <code>git add</code> and <code>git rm</code>, and only <i>then</i> do you commit
those changes.  This intermediate stage between the last and the next
commit is called the <b>staging area</b>.
</p>

<p>
It would seem natural to use a commit or tree object to represent the
staging area, but Git actually and uses a completely different
mechanism, in the form of what it calls the <b>index file</b>.
</p>

<p>
After a commit, the index file is a sort of copy of that commit: it
holds the same path/blob association than the corresponding tree.  But
it also holds extra information about files in the worktree, like
their creation/modification time, so <code>git status</code> doesn&rsquo;t often need
to actually compare files: it just checks that their modification time
is the same as the one stored in the index file, and only if it isn&rsquo;t
does it perform an actual comparison.
</p>

<p>
You can thus consider the index file as a three-way association list:
not only paths with blobs, but also paths with actual filesystem
entries.
</p>

<p>
Another important characteristic of the <b>index file</b> is that unlike a
tree, it can represent inconsistent states, like a merge conflict,
whereas a tree is always a complete, unambiguous representation.
</p>

<p>
When you commit, what git actually does is turn the index file into a
new tree object.  To summarize:
</p>

<ol class="org-ol">
<li><p>
When the repository is “clean”, the index file holds the exact
same contents as the HEAD commit, plus metadata about the
corresponding filesystem entries.  For instance, it may contain
something like:
</p>

<blockquote>
<p>
There&rsquo;s a file called <code>src/disp.c</code> whose contents are blob
797441c76e59e28794458b39b0f1eff4c85f4fa0.  The real <code>src/disp.c</code>
file, in the worktree, was created on 2023-07-15
15:28:29.168572151, and last modified 2023-07-15
15:28:29.1689427709.  It is stored on device 65026, inode 8922881.
</p>
</blockquote></li>

<li>When you <code>git add</code> or <code>git rm</code>, the index file is modified
accordingly.  In the example above, if you modify <code>src/disp.c</code>,
and <code>add</code> your changes, the index file will be updated with a new
blob ID (the blob itself will also be created in the process, of
course), and the various file metadata will be updated as well so
<code>git status</code> knows when not to compare file contents.</li>

<li>When you <code>git commit</code> those changes, a new tree is produced from
the index file, a new commit object is generated with that tree,
branches are updated and we&rsquo;re done.</li>
</ol>

<div class="note" id="orgef622c8">
<p>
<b>A note on words</b>
</p>

<p>
The staging area and the index are thus the same thing, but the name
&ldquo;staging area&rdquo; is more the name of the git user-exposed feature
(that could have been implemented otherwise), the abstraction if you
will; while &ldquo;index file&rdquo; refers specifically to the way this
abstract feature is actually implemented in git.
</p>

</div>
</div>
</div>
<div id="outline-container-index_read" class="outline-3">
<h3 id="index_read"><span class="section-number-3">8.2.</span> Parsing the index</h3>
<div class="outline-text-3" id="text-index_read">
<p>
The index file is by far the most complicated piece of data a Git
repository can hold.  Its complete documentation can be found in Git
source tree or rendered <a href="https://git-scm.com/docs/index-format">on the git website</a>.  It&rsquo;s made of three parts:
</p>

<ul class="org-ul">
<li>An header with the format version number and the number of entries
the index holds;</li>
<li>A series of entries, sorted, each representing a file; padded to
multiple of 8 bytes.</li>
<li>A series of optional extensions, which we&rsquo;ll ignore.</li>
</ul>

<p>
The first thing we need to represent is a single entry.  It actually
holds quite a lot of stuff, I&rsquo;m leaving the details in comments.
It&rsquo;s worth observing that an entry stores <b>both</b> the SHA-1 of the
associated blob in the object store <i>and</i> a ton of metadata about the
actual file on the actual filesystem.  Again, this is because
<code>git/wyag status</code> will need to determine which files in the index were
modified: it is much more efficient to begin by checking the
last-modified timestamp and comparing it with a known values, before
comparing actual files.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">GitIndexEntry</span> (<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, ctime<span class="org-operator">=</span><span class="org-constant">None</span>, mtime<span class="org-operator">=</span><span class="org-constant">None</span>, dev<span class="org-operator">=</span><span class="org-constant">None</span>, ino<span class="org-operator">=</span><span class="org-constant">None</span>,
                 mode_type<span class="org-operator">=</span><span class="org-constant">None</span>, mode_perms<span class="org-operator">=</span><span class="org-constant">None</span>, uid<span class="org-operator">=</span><span class="org-constant">None</span>, gid<span class="org-operator">=</span><span class="org-constant">None</span>,
                 fsize<span class="org-operator">=</span><span class="org-constant">None</span>, sha<span class="org-operator">=</span><span class="org-constant">None</span>, flag_assume_valid<span class="org-operator">=</span><span class="org-constant">None</span>,
                 flag_stage<span class="org-operator">=</span><span class="org-constant">None</span>, name<span class="org-operator">=</span><span class="org-constant">None</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">The last time a file's metadata changed.  This is a pair</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">(timestamp in seconds, nanoseconds)</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">ctime</span> <span class="org-operator">=</span> ctime
        <span class="org-comment-delimiter"># </span><span class="org-comment">The last time a file's data changed.  This is a pair</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">(timestamp in seconds, nanoseconds)</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">mtime</span> <span class="org-operator">=</span> mtime
        <span class="org-comment-delimiter"># </span><span class="org-comment">The ID of device containing this file</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">dev</span> <span class="org-operator">=</span> dev
        <span class="org-comment-delimiter"># </span><span class="org-comment">The file's inode number</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">ino</span> <span class="org-operator">=</span> ino
        <span class="org-comment-delimiter"># </span><span class="org-comment">The object type, either b1000 (regular), b1010 (symlink),</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">b1110 (gitlink).</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">mode_type</span> <span class="org-operator">=</span> mode_type
        <span class="org-comment-delimiter"># </span><span class="org-comment">The object permissions, an integer.</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">mode_perms</span> <span class="org-operator">=</span> mode_perms
        <span class="org-comment-delimiter"># </span><span class="org-comment">User ID of owner</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">uid</span> <span class="org-operator">=</span> uid
        <span class="org-comment-delimiter"># </span><span class="org-comment">Group ID of ownner</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">gid</span> <span class="org-operator">=</span> gid
        <span class="org-comment-delimiter"># </span><span class="org-comment">Size of this object, in bytes</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">fsize</span> <span class="org-operator">=</span> fsize
        <span class="org-comment-delimiter"># </span><span class="org-comment">The object's SHA</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">sha</span> <span class="org-operator">=</span> sha
        <span class="org-keyword">self</span>.<span class="org-variable-name">flag_assume_valid</span> <span class="org-operator">=</span> flag_assume_valid
        <span class="org-keyword">self</span>.<span class="org-variable-name">flag_stage</span> <span class="org-operator">=</span> flag_stage
        <span class="org-comment-delimiter"># </span><span class="org-comment">Name of the object (full path this time!)</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">name</span> <span class="org-operator">=</span> name
</pre>
</div>

<p>
The index file is a binary file, likely for performance reasons.  The
format is reasonably simple, though.  It begins with a header with the
<code>DIRC</code> magic bytes, a version number and the total number of entries
in that index file.  We create the <code>GitIndex</code> class to hold them:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">GitIndex</span> (<span class="org-builtin">object</span>):
    <span class="org-variable-name">version</span> <span class="org-operator">=</span> <span class="org-constant">None</span>
    <span class="org-variable-name">entries</span> <span class="org-operator">=</span> []
    <span class="org-comment-delimiter"># </span><span class="org-comment">ext = None</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">sha = None</span>

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, version<span class="org-operator">=</span>2, entries<span class="org-operator">=</span><span class="org-constant">None</span>):
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> entries:
            <span class="org-variable-name">entries</span> <span class="org-operator">=</span> <span class="org-builtin">list</span>()

        <span class="org-keyword">self</span>.<span class="org-variable-name">version</span> <span class="org-operator">=</span> version
        <span class="org-keyword">self</span>.<span class="org-variable-name">entries</span> <span class="org-operator">=</span> entries
</pre>
</div>

<p>
And a parser to read index files into those objects.  After reading
the 12-bytes header, we just parse entries in the order they appear.
An entry begins with a set of fixed-length data, followed by a
variable-length name.
</p>

<p>
The code is quite straightforward, but as it&rsquo;s reading a binary
format, it feels more messy than what we did so far.  We use the
<code>int.from_bytes(bytes, endianness)</code> a lot to read raw bytes into an
integer, and just a few bitwise operations to separate data
that share the same byte.
</p>

<p>
(This format was probably designed so index files could just be
<code>mmapp()ed</code> to memory, and read directly as C structs, with an index
built in O(n) time in most cases.  This kind of approach tends to
produce more elegant code in C than in Python…)
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">index_read</span>(repo):
    <span class="org-variable-name">index_file</span> <span class="org-operator">=</span> repo_file(repo, <span class="org-string">"index"</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">New repositories have no index!</span>
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> os.path.exists(index_file):
        <span class="org-keyword">return</span> GitIndex()

    <span class="org-keyword">with</span> <span class="org-builtin">open</span>(index_file, <span class="org-string">'rb'</span>) <span class="org-keyword">as</span> f:
        <span class="org-variable-name">raw</span> <span class="org-operator">=</span> f.read()

    <span class="org-variable-name">header</span> <span class="org-operator">=</span> raw[:12]
    <span class="org-variable-name">signature</span> <span class="org-operator">=</span> header[:4]
    <span class="org-keyword">assert</span> signature <span class="org-operator">==</span> b<span class="org-string">"DIRC"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">Stands for "DirCache"</span>
    <span class="org-variable-name">version</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>.from_bytes(header[4:8], <span class="org-string">"big"</span>)
    <span class="org-keyword">assert</span> version <span class="org-operator">==</span> 2, <span class="org-string">"wyag only supports index file version 2"</span>
    <span class="org-variable-name">count</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>.from_bytes(header[8:12], <span class="org-string">"big"</span>)

    <span class="org-variable-name">entries</span> <span class="org-operator">=</span> <span class="org-builtin">list</span>()

    <span class="org-variable-name">content</span> <span class="org-operator">=</span> raw[12:]
    <span class="org-variable-name">idx</span> <span class="org-operator">=</span> 0
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(0, count):
        <span class="org-comment-delimiter"># </span><span class="org-comment">Read creation time, as a unix timestamp (seconds since</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">1970-01-01 00:00:00, the "epoch")</span>
        <span class="org-variable-name">ctime_s</span> <span class="org-operator">=</span>  <span class="org-builtin">int</span>.from_bytes(content[idx: idx<span class="org-operator">+</span>4], <span class="org-string">"big"</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Read creation time, as nanoseconds after that timestamps,</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">for extra precision.</span>
        <span class="org-variable-name">ctime_ns</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>.from_bytes(content[idx<span class="org-operator">+</span>4: idx<span class="org-operator">+</span>8], <span class="org-string">"big"</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Same for modification time: first seconds from epoch.</span>
        <span class="org-variable-name">mtime_s</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>.from_bytes(content[idx<span class="org-operator">+</span>8: idx<span class="org-operator">+</span>12], <span class="org-string">"big"</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Then extra nanoseconds</span>
        <span class="org-variable-name">mtime_ns</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>.from_bytes(content[idx<span class="org-operator">+</span>12: idx<span class="org-operator">+</span>16], <span class="org-string">"big"</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Device ID</span>
        <span class="org-variable-name">dev</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>.from_bytes(content[idx<span class="org-operator">+</span>16: idx<span class="org-operator">+</span>20], <span class="org-string">"big"</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Inode</span>
        <span class="org-variable-name">ino</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>.from_bytes(content[idx<span class="org-operator">+</span>20: idx<span class="org-operator">+</span>24], <span class="org-string">"big"</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Ignored.</span>
        <span class="org-variable-name">unused</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>.from_bytes(content[idx<span class="org-operator">+</span>24: idx<span class="org-operator">+</span>26], <span class="org-string">"big"</span>)
        <span class="org-keyword">assert</span> 0 <span class="org-operator">==</span> unused
        <span class="org-variable-name">mode</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>.from_bytes(content[idx<span class="org-operator">+</span>26: idx<span class="org-operator">+</span>28], <span class="org-string">"big"</span>)
        <span class="org-variable-name">mode_type</span> <span class="org-operator">=</span> mode <span class="org-operator">&gt;&gt;</span> 12
        <span class="org-keyword">assert</span> mode_type <span class="org-keyword">in</span> [0b1000, 0b1010, 0b1110]
        <span class="org-variable-name">mode_perms</span> <span class="org-operator">=</span> mode <span class="org-operator">&amp;</span> 0b0000000111111111
        <span class="org-comment-delimiter"># </span><span class="org-comment">User ID</span>
        <span class="org-variable-name">uid</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>.from_bytes(content[idx<span class="org-operator">+</span>28: idx<span class="org-operator">+</span>32], <span class="org-string">"big"</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Group ID</span>
        <span class="org-variable-name">gid</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>.from_bytes(content[idx<span class="org-operator">+</span>32: idx<span class="org-operator">+</span>36], <span class="org-string">"big"</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Size</span>
        <span class="org-variable-name">fsize</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>.from_bytes(content[idx<span class="org-operator">+</span>36: idx<span class="org-operator">+</span>40], <span class="org-string">"big"</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">SHA (object ID).  We'll store it as a lowercase hex string</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">for consistency.</span>
        <span class="org-variable-name">sha</span> <span class="org-operator">=</span> <span class="org-builtin">format</span>(<span class="org-builtin">int</span>.from_bytes(content[idx<span class="org-operator">+</span>40: idx<span class="org-operator">+</span>60], <span class="org-string">"big"</span>), <span class="org-string">"040x"</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Flags we're going to ignore</span>
        <span class="org-variable-name">flags</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>.from_bytes(content[idx<span class="org-operator">+</span>60: idx<span class="org-operator">+</span>62], <span class="org-string">"big"</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Parse flags</span>
        <span class="org-variable-name">flag_assume_valid</span> <span class="org-operator">=</span> (flags <span class="org-operator">&amp;</span> 0b1000000000000000) <span class="org-operator">!=</span> 0
        <span class="org-variable-name">flag_extended</span> <span class="org-operator">=</span> (flags <span class="org-operator">&amp;</span> 0b0100000000000000) <span class="org-operator">!=</span> 0
        <span class="org-keyword">assert</span> <span class="org-keyword">not</span> flag_extended
        <span class="org-variable-name">flag_stage</span> <span class="org-operator">=</span>  flags <span class="org-operator">&amp;</span> 0b0011000000000000
        <span class="org-comment-delimiter"># </span><span class="org-comment">Length of the name.  This is stored on 12 bits, some max</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">value is 0xFFF, 4095.  Since names can occasionally go</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">beyond that length, git treats 0xFFF as meaning at least</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">0xFFF, and looks for the final 0x00 to find the end of the</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">name --- at a small, and probably very rare, performance</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">cost.</span>
        <span class="org-variable-name">name_length</span> <span class="org-operator">=</span> flags <span class="org-operator">&amp;</span> 0b0000111111111111

        <span class="org-comment-delimiter"># </span><span class="org-comment">We've read 62 bytes so far.</span>
        <span class="org-variable-name">idx</span> <span class="org-operator">+=</span> 62

        <span class="org-keyword">if</span> name_length <span class="org-operator">&lt;</span> 0xFFF:
            <span class="org-keyword">assert</span> content[idx <span class="org-operator">+</span> name_length] <span class="org-operator">==</span> 0x00
            <span class="org-variable-name">raw_name</span> <span class="org-operator">=</span> content[idx:idx<span class="org-operator">+</span>name_length]
            <span class="org-variable-name">idx</span> <span class="org-operator">+=</span> name_length <span class="org-operator">+</span> 1
        <span class="org-keyword">else</span>:
            <span class="org-builtin">print</span>(f<span class="org-string">"Notice: Name is 0x</span>{name_length:X}<span class="org-string"> bytes long."</span>)
            <span class="org-comment-delimiter"># </span><span class="org-comment">This probably wasn't tested enough.  It works with a</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">path of exactly 0xFFF bytes.  Any extra bytes broke</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">something between git, my shell and my filesystem.</span>
            <span class="org-variable-name">null_idx</span> <span class="org-operator">=</span> content.find(b<span class="org-string">'</span><span class="org-constant">\x00</span><span class="org-string">'</span>, idx <span class="org-operator">+</span> 0xFFF)
            <span class="org-variable-name">raw_name</span> <span class="org-operator">=</span> content[idx: null_idx]
            <span class="org-variable-name">idx</span> <span class="org-operator">=</span> null_idx <span class="org-operator">+</span> 1

        <span class="org-comment-delimiter"># </span><span class="org-comment">Just parse the name as utf8.</span>
        <span class="org-variable-name">name</span> <span class="org-operator">=</span> raw_name.decode(<span class="org-string">"utf8"</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Data is padded on multiples of eight bytes for pointer</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">alignment, so we skip as many bytes as we need for the next</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">read to start at the right position.</span>

        <span class="org-variable-name">idx</span> <span class="org-operator">=</span> 8 <span class="org-operator">*</span> ceil(idx <span class="org-operator">/</span> 8)

        <span class="org-comment-delimiter"># </span><span class="org-comment">And we add this entry to our list.</span>
        entries.append(GitIndexEntry(ctime<span class="org-operator">=</span>(ctime_s, ctime_ns),
                                     mtime<span class="org-operator">=</span>(mtime_s,  mtime_ns),
                                     dev<span class="org-operator">=</span>dev,
                                     ino<span class="org-operator">=</span>ino,
                                     mode_type<span class="org-operator">=</span>mode_type,
                                     mode_perms<span class="org-operator">=</span>mode_perms,
                                     uid<span class="org-operator">=</span>uid,
                                     gid<span class="org-operator">=</span>gid,
                                     fsize<span class="org-operator">=</span>fsize,
                                     sha<span class="org-operator">=</span>sha,
                                     flag_assume_valid<span class="org-operator">=</span>flag_assume_valid,
                                     flag_stage<span class="org-operator">=</span>flag_stage,
                                     name<span class="org-operator">=</span>name))

    <span class="org-keyword">return</span> GitIndex(version<span class="org-operator">=</span>version, entries<span class="org-operator">=</span>entries)
</pre>
</div>
</div>
</div>
<div id="outline-container-cmd-ls-files" class="outline-3">
<h3 id="cmd-ls-files"><span class="section-number-3">8.3.</span> The ls-files command</h3>
<div class="outline-text-3" id="text-cmd-ls-files">
<p>
<code>git ls-files</code> displays the names of files in the staging area, with,
as usual, a ton of options.  Our <code>ls-files</code> will be much simpler,
<i>but</i> we&rsquo;ll add a <code>--verbose</code> option that doesn&rsquo;t exist in git, just
so we can display every single bit of info in the index file.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argsp</span> <span class="org-operator">=</span> argsubparsers.add_parser(<span class="org-string">"ls-files"</span>, <span class="org-builtin">help</span> <span class="org-operator">=</span> <span class="org-string">"List all the stage files"</span>)
argsp.add_argument(<span class="org-string">"--verbose"</span>, action<span class="org-operator">=</span><span class="org-string">"store_true"</span>, <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Show everything."</span>)

<span class="org-keyword">def</span> <span class="org-function-name">cmd_ls_files</span>(args):
    <span class="org-variable-name">repo</span> <span class="org-operator">=</span> repo_find()
    <span class="org-variable-name">index</span> <span class="org-operator">=</span> index_read(repo)
    <span class="org-keyword">if</span> args.verbose:
        <span class="org-builtin">print</span>(f<span class="org-string">"Index file format v</span>{index.version}<span class="org-string">, containing </span>{<span class="org-builtin">len</span>(index.entries)}<span class="org-string"> entries."</span>)

    <span class="org-keyword">for</span> e <span class="org-keyword">in</span> index.entries:
        <span class="org-builtin">print</span>(e.name)
        <span class="org-keyword">if</span> args.verbose:
            <span class="org-variable-name">entry_type</span> <span class="org-operator">=</span> { 0b1000: <span class="org-string">"regular file"</span>,
                           0b1010: <span class="org-string">"symlink"</span>,
                           0b1110: <span class="org-string">"git link"</span> }[e.mode_type]
            <span class="org-builtin">print</span>(f<span class="org-string">"  </span>{entry_type}<span class="org-string"> with perms: </span>{e.mode_perms:o}<span class="org-string">"</span>)
            <span class="org-builtin">print</span>(f<span class="org-string">"  on blob: </span>{e.sha}<span class="org-string">"</span>)
            <span class="org-builtin">print</span>(f<span class="org-string">"  created: </span>{datetime.fromtimestamp(e.ctime[0])}<span class="org-string">.</span>{e.ctime[1]}<span class="org-string">, modified: </span>{datetime.fromtimestamp(e.mtime[0])}<span class="org-string">.</span>{e.mtime[1]}<span class="org-string">"</span>)
            <span class="org-builtin">print</span>(f<span class="org-string">"  device: </span>{e.dev}<span class="org-string">, inode: </span>{e.ino}<span class="org-string">"</span>)
            <span class="org-builtin">print</span>(f<span class="org-string">"  user: </span>{pwd.getpwuid(e.uid).pw_name}<span class="org-string"> (</span>{e.uid}<span class="org-string">)  group: </span>{grp.getgrgid(e.gid).gr_name}<span class="org-string"> (</span>{e.gid}<span class="org-string">)"</span>)
            <span class="org-builtin">print</span>(f<span class="org-string">"  flags: stage=</span>{e.flag_stage}<span class="org-string"> assume_valid=</span>{e.flag_assume_valid}<span class="org-string">"</span>)
</pre>
</div>

<p>
If you run ls-files, you&rsquo;ll notice that on a “clean” worktree (an
unmodified checkout of <code>HEAD</code>), it lists all files on <code>HEAD</code>.  Again,
the index is not a <i>delta</i> (a set of differences) from the <code>HEAD</code>
commit, but starts as a copy of it, in a different format.
</p>
</div>
</div>
<div id="outline-container-cmd-check-ignore" class="outline-3">
<h3 id="cmd-check-ignore"><span class="section-number-3">8.4.</span> A detour: the check-ignore command</h3>
<div class="outline-text-3" id="text-cmd-check-ignore">
<p>
We want to write <code>status</code>, but <code>status</code> needs to know about ignore
rules, that are stored in the various <code>.gitignore</code> files.  So we first
need to add some rudimentary support for ignore files in <code>wyag</code>.
We&rsquo;ll expose this support as the <code>check-ignore</code> command, which takes a
list of paths and outputs back those of those paths that should be
ignored.
</p>

<p>
Again, the command parser is trivial:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argsp</span> <span class="org-operator">=</span> argsubparsers.add_parser(<span class="org-string">"check-ignore"</span>, <span class="org-builtin">help</span> <span class="org-operator">=</span> <span class="org-string">"Check path(s) against ignore rules."</span>)
argsp.add_argument(<span class="org-string">"path"</span>, nargs<span class="org-operator">=</span><span class="org-string">"+"</span>, <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Paths to check"</span>)
</pre>
</div>

<p>
And the function is just as simple:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cmd_check_ignore</span>(args):
    <span class="org-variable-name">repo</span> <span class="org-operator">=</span> repo_find()
    <span class="org-variable-name">rules</span> <span class="org-operator">=</span> gitignore_read(repo)
    <span class="org-keyword">for</span> path <span class="org-keyword">in</span> args.path:
        <span class="org-keyword">if</span> check_ignore(rules, path):
            <span class="org-builtin">print</span>(path)
</pre>
</div>

<p>
But of course, most of the function we call don&rsquo;t exist yet in wyag.
We&rsquo;ll begin by writing a reader for rules in ignore files,
<code>gitignore_read()</code>.  The syntax of those rules is quite simple: each
line in an ignore file is an exclusion pattern, so files that match
this pattern are ignored by <code>status</code>, <code>add -A</code> and so on.  There are
three special cases, though:
</p>

<ol class="org-ol">
<li>Lines that begin with an exclamation mark <code>!</code> <i>negate</i> the pattern
(files that match this pattern are <i>included</i>, even they were
ignored by an earlier pattern)</li>
<li>Lines that begin with a dash <code>#</code> are comments, and are skipped.</li>
<li>A backslash <code>\</code> at the beginning treats <code>!</code> and <code>#</code> as literal
characters.</li>
</ol>

<p>
First, a parser for a single pattern. This parser returns a pair: the
pattern itself, and a boolean to indicate if files matching the
pattern <i>should</i> be excluded (<code>True</code>) or included (<code>False</code>).  In other
words, <code>False</code> if the pattern did start with <code>!</code>, <code>True</code> otherwise.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">gitignore_parse1</span>(raw):
    <span class="org-variable-name">raw</span> <span class="org-operator">=</span> raw.strip() <span class="org-comment-delimiter"># </span><span class="org-comment">Remove leading/trailing spaces</span>

    <span class="org-keyword">if</span> <span class="org-keyword">not</span> raw <span class="org-keyword">or</span> raw[0] <span class="org-operator">==</span> <span class="org-string">"#"</span>:
        <span class="org-keyword">return</span> <span class="org-constant">None</span>
    <span class="org-keyword">elif</span> raw[0] <span class="org-operator">==</span> <span class="org-string">"!"</span>:
        <span class="org-keyword">return</span> (raw[1:], <span class="org-constant">False</span>)
    <span class="org-keyword">elif</span> raw[0] <span class="org-operator">==</span> <span class="org-string">"</span><span class="org-constant">\\</span><span class="org-string">"</span>:
        <span class="org-keyword">return</span> (raw[1:], <span class="org-constant">True</span>)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> (raw, <span class="org-constant">True</span>)
</pre>
</div>

<p>
Parsing a file is just collecting all rules in that file.  Notice this
function doesn&rsquo;t parse <i>files</i>, but just lists of lines: that&rsquo;s
because we&rsquo;ll need to read rules from git blobs as well, and not just
regular files.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">gitignore_parse</span>(lines):
    <span class="org-variable-name">ret</span> <span class="org-operator">=</span> <span class="org-builtin">list</span>()

    <span class="org-keyword">for</span> line <span class="org-keyword">in</span> lines:
        <span class="org-variable-name">parsed</span> <span class="org-operator">=</span> gitignore_parse1(line)
        <span class="org-keyword">if</span> parsed:
            ret.append(parsed)

    <span class="org-keyword">return</span> ret
</pre>
</div>

<p>
Last thing we need to do is collect the various ignore files.  They
come in two kinds:
</p>

<ul class="org-ul">
<li>Some of these files <b>live in the index</b>: they&rsquo;re the various
<code>gitignore</code> files.  Emphasis on the plural; although there often is
only one such file, at the root, there can be one in each
directory, and it applies to this directory and its subdirectories.
I&rsquo;ll call those <b>scoped</b>, because they only apply to paths under
their directory.</li>
<li>The others live <b>outside the index</b>.  They&rsquo;re the global ignore
file (usually in <code>~/.config/git/ignore</code>) and the
repository-specific <code>.git/info/exclude</code>.  I call those <b>absolute</b>,
because they apply everywhere, but at a lower priority.</li>
</ul>

<p>
Again, a class to hold that: a list of absolute rules, a dict
(hashmap) of relative rules.  The keys to this hashmap are
<b>directories</b>, relative to the root of a worktree.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">GitIgnore</span>(<span class="org-builtin">object</span>):
    <span class="org-variable-name">absolute</span> <span class="org-operator">=</span> <span class="org-constant">None</span>
    <span class="org-variable-name">scoped</span> <span class="org-operator">=</span> <span class="org-constant">None</span>

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, absolute, scoped):
        <span class="org-keyword">self</span>.<span class="org-variable-name">absolute</span> <span class="org-operator">=</span> absolute
        <span class="org-keyword">self</span>.<span class="org-variable-name">scoped</span> <span class="org-operator">=</span> scoped
</pre>
</div>

<p>
And finally our function to collect all gitignore rules in a
repository, and return a <code>GitIgnore</code> object.  Notice how it reads
scoped files from the index, and not the worktree: only <i>staged</i>
<code>.gitignore</code> files matter (also remember: HEAD is <i>already</i> staged &#x2014;
the staging area is a copy, not a delta).
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">gitignore_read</span>(repo):
    <span class="org-variable-name">ret</span> <span class="org-operator">=</span> GitIgnore(absolute<span class="org-operator">=</span><span class="org-builtin">list</span>(), scoped<span class="org-operator">=</span><span class="org-builtin">dict</span>())

    <span class="org-comment-delimiter"># </span><span class="org-comment">Read local configuration in .git/info/exclude</span>
    <span class="org-variable-name">repo_file</span> <span class="org-operator">=</span> os.path.join(repo.gitdir, <span class="org-string">"info/exclude"</span>)
    <span class="org-keyword">if</span> os.path.exists(repo_file):
        <span class="org-keyword">with</span> <span class="org-builtin">open</span>(repo_file, <span class="org-string">"r"</span>) <span class="org-keyword">as</span> f:
            ret.absolute.append(gitignore_parse(f.readlines()))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Global configuration</span>
    <span class="org-keyword">if</span> <span class="org-string">"XDG_CONFIG_HOME"</span> <span class="org-keyword">in</span> os.environ:
        <span class="org-variable-name">config_home</span> <span class="org-operator">=</span> os.environ[<span class="org-string">"XDG_CONFIG_HOME"</span>]
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">config_home</span> <span class="org-operator">=</span> os.path.expanduser(<span class="org-string">"~/.config"</span>)
    <span class="org-variable-name">global_file</span> <span class="org-operator">=</span> os.path.join(config_home, <span class="org-string">"git/ignore"</span>)

    <span class="org-keyword">if</span> os.path.exists(global_file):
        <span class="org-keyword">with</span> <span class="org-builtin">open</span>(global_file, <span class="org-string">"r"</span>) <span class="org-keyword">as</span> f:
            ret.absolute.append(gitignore_parse(f.readlines()))

    <span class="org-comment-delimiter"># </span><span class="org-comment">.gitignore files in the index</span>
    <span class="org-variable-name">index</span> <span class="org-operator">=</span> index_read(repo)

    <span class="org-keyword">for</span> entry <span class="org-keyword">in</span> index.entries:
        <span class="org-keyword">if</span> entry.name <span class="org-operator">==</span> <span class="org-string">".gitignore"</span> <span class="org-keyword">or</span> entry.name.endswith(<span class="org-string">"/.gitignore"</span>):
            <span class="org-variable-name">dir_name</span> <span class="org-operator">=</span> os.path.dirname(entry.name)
            <span class="org-variable-name">contents</span> <span class="org-operator">=</span> object_read(repo, entry.sha)
            <span class="org-variable-name">lines</span> <span class="org-operator">=</span> contents.blobdata.decode(<span class="org-string">"utf8"</span>).splitlines()
            ret.<span class="org-variable-name">scoped</span>[dir_name] <span class="org-operator">=</span> gitignore_parse(lines)
    <span class="org-keyword">return</span> ret
</pre>
</div>

<p>
We&rsquo;re almost there.  To tie everything together, we need the
<code>check_ignore</code> function that matches a path, relative to the root of a
worktree, against a set of rules.  This is how this function will
work:
</p>

<ul class="org-ul">
<li>It will first try to match this path against the <b>scoped</b> rules.
It will do this from the deepest parent of the path to the
farthest.  That is, if the path is
<code>src/support/w32/legacy/sound.c~</code>, it will first look for rules in
<code>src/support/w32/legacy/.gitignore</code>, then
<code>src/support/w32/.gitignore</code>, <code>src/support/.gitignore</code>, and so on
up to simply <code>.gitignore"</code> at the root.</li>
<li>If nothing matches, it will continue with the <b>absolute</b> rules.</li>
</ul>

<p>
We write three small support functions.  One to match a path against a
set of rules, and return the result of the last matching rule.  Notice
how it&rsquo;s not a real boolean functions, since it has <b>three</b> possible
return values: <code>True</code>, <code>False</code> but also <code>None</code>.  It returns <code>None</code> if
nothing matched, so the caller knows it should continue trying with
more general ignore files (eg, go one directory level up).
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">check_ignore1</span>(rules, path):
    <span class="org-variable-name">result</span> <span class="org-operator">=</span> <span class="org-constant">None</span>
    <span class="org-keyword">for</span> (pattern, value) <span class="org-keyword">in</span> rules:
        <span class="org-keyword">if</span> fnmatch(path, pattern):
            <span class="org-variable-name">result</span> <span class="org-operator">=</span> value
    <span class="org-keyword">return</span> result
</pre>
</div>

<p>
A function to match against the dictionary of <b>scoped</b> rules (the
various <code>.gitignore</code> files).  It just starts at the path&rsquo;s directory
then moves up to the parent directory, recursively, until it has
tested root.  Notice that this function (and the next two as well),
never breaks <b>inside</b> a given <code>.gitignore</code> file.  Even if a rule
matches, they keep going through the file, because another rule there
may negate reverse the effect (rules are processed in order, so if you
want to exclude <code>*.c</code> but not <code>generator.c</code>, the general rule must
come before the specific one).  But as soon as at least one rule
matched in a file, we drop the remaining files, because a more general
file never cancels the effect of a more specific one (this is why
<code>check_ignore1</code> is ternary and not boolean)
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">check_ignore_scoped</span>(rules, path):
    <span class="org-variable-name">parent</span> <span class="org-operator">=</span> os.path.dirname(path)
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-keyword">if</span> parent <span class="org-keyword">in</span> rules:
            <span class="org-variable-name">result</span> <span class="org-operator">=</span> check_ignore1(rules[parent], path)
            <span class="org-keyword">if</span> result <span class="org-operator">!=</span> <span class="org-constant">None</span>:
                <span class="org-keyword">return</span> result
        <span class="org-keyword">if</span> parent <span class="org-operator">==</span> <span class="org-string">""</span>:
            <span class="org-keyword">break</span>
        <span class="org-variable-name">parent</span> <span class="org-operator">=</span> os.path.dirname(parent)
    <span class="org-keyword">return</span> <span class="org-constant">None</span>
</pre>
</div>

<p>
A much simpler function to match against the list of absolute rules.
Notice that the order we push those rules to the list matters (we
<i>did</i> read the repository rules before the global ones!)
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">check_ignore_absolute</span>(rules, path):
    <span class="org-variable-name">parent</span> <span class="org-operator">=</span> os.path.dirname(path)
    <span class="org-keyword">for</span> ruleset <span class="org-keyword">in</span> rules:
        <span class="org-variable-name">result</span> <span class="org-operator">=</span> check_ignore1(ruleset, path)
        <span class="org-keyword">if</span> result <span class="org-operator">!=</span> <span class="org-constant">None</span>:
            <span class="org-keyword">return</span> result
    <span class="org-keyword">return</span> <span class="org-constant">False</span> <span class="org-comment-delimiter"># </span><span class="org-comment">This is a reasonable default at this point.</span>
</pre>
</div>

<p>
And finally, a function to bind them all.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">check_ignore</span>(rules, path):
    <span class="org-keyword">if</span> os.path.isabs(path):
        <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(<span class="org-string">"This function requires path to be relative to the repository's root"</span>)

    <span class="org-variable-name">result</span> <span class="org-operator">=</span> check_ignore_scoped(rules.scoped, path)
    <span class="org-keyword">if</span> result <span class="org-operator">!=</span> <span class="org-constant">None</span>:
        <span class="org-keyword">return</span> result

    <span class="org-keyword">return</span> check_ignore_absolute(rules.absolute, path)
</pre>
</div>

<p>
You can now call <code>wyag check-ignore</code>.  On its own source tree:
</p>

<pre class="example" id="org1f52f70">
$ wyag check-ignore hello.el hello.elc hello.html wyag.zip wyag.tar
hello.elc
hello.html
wyag.zip
</pre>

<div class="warning" id="org95d0957">
<p>
<b>This is only an approximation</b>
</p>

<p>
This isn&rsquo;t a perfect reimplementation.  In particular, excluding
whole directories with a rule that&rsquo;s only the directory name (eg
<code>__pycache__</code>) won&rsquo;t work, because <code>fnmatch</code> would want the pattern
as <code>__pycache__/**</code>.  If you really want to play with ignore rules,
<a href="https://github.com/mherrmann/gitignore_parser">this may be a good
starting point</a>.
</p>

</div>
</div>
</div>
<div id="outline-container-cmd-status" class="outline-3">
<h3 id="cmd-status"><span class="section-number-3">8.5.</span> The status command</h3>
<div class="outline-text-3" id="text-cmd-status">
<p>
<code>status</code> is more complex than <code>ls-files</code>, because it needs to compare
the index with both HEAD <i>and</i> the actual filesystem.  You call <code>git
status</code> to know which files were added, removed or modified since the
last commit, and which of these changes are actually staged, and will
make it to the next commit.  So <code>status</code> actually compares the <code>HEAD</code>
with the staging area, and the staging area with the worktree.  This
is what its output looks like:
</p>

<pre class="example" id="org70088e1">
On branch master

Changes to be committed:
  (use "git restore --staged &lt;file&gt;..." to unstage)
	modified:   write-yourself-a-git.org

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git restore &lt;file&gt;..." to discard changes in working directory)
	modified:   write-yourself-a-git.org

Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)
	org-html-themes/
	wl-copy
</pre>

<p>
We&rsquo;ll implement <code>status</code> in three parts: first the active branch or
“detached HEAD”, then the difference between the index and the
worktree (“Changes not staged for commit”), then the difference
between HEAD and the index (“Changes to be committed” and “Untracked
files”).
</p>

<p>
The public interface is dead simple, our status will take no argument:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argsp</span> <span class="org-operator">=</span> argsubparsers.add_parser(<span class="org-string">"status"</span>, <span class="org-builtin">help</span> <span class="org-operator">=</span> <span class="org-string">"Show the working tree status."</span>)
</pre>
</div>

<p>
And the bridge function just calls the three component functions in order:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cmd_status</span>(_):
    <span class="org-variable-name">repo</span> <span class="org-operator">=</span> repo_find()
    <span class="org-variable-name">index</span> <span class="org-operator">=</span> index_read(repo)

    cmd_status_branch(repo)
    cmd_status_head_index(repo, index)
    <span class="org-builtin">print</span>()
    cmd_status_index_worktree(repo, index)
</pre>
</div>
</div>
<div id="outline-container-org6fc9507" class="outline-4">
<h4 id="org6fc9507"><span class="section-number-4">8.5.1.</span> Finding the active branch</h4>
<div class="outline-text-4" id="text-8-5-1">
<p>
First we need to know if we&rsquo;re on a branch, and if so which one.  We
do this by just looking at <code>.git/HEAD</code>.  It should contain either an
hexadecimal ID (a ref to a commit, in detached HEAD state), or an
indirect reference to something in <code>refs/heads/</code>: the active branch.
We either return its name, or <code>False</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">branch_get_active</span>(repo):
    <span class="org-keyword">with</span> <span class="org-builtin">open</span>(repo_file(repo, <span class="org-string">"HEAD"</span>), <span class="org-string">"r"</span>) <span class="org-keyword">as</span> f:
        <span class="org-variable-name">head</span> <span class="org-operator">=</span> f.read()

    <span class="org-keyword">if</span> head.startswith(<span class="org-string">"ref: refs/heads/"</span>):
        <span class="org-keyword">return</span>(head[16:<span class="org-operator">-</span>1])
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> <span class="org-constant">False</span>
</pre>
</div>

<p>
Based on this, we can write the first of the three <code>cmd_status_*</code>
functions the bridge calls.  This one prints the name of the active
branch, or the hash of the detached HEAD:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cmd_status_branch</span>(repo):
    <span class="org-variable-name">branch</span> <span class="org-operator">=</span> branch_get_active(repo)
    <span class="org-keyword">if</span> branch:
        <span class="org-builtin">print</span>(f<span class="org-string">"On branch </span>{branch}<span class="org-string">."</span>)
    <span class="org-keyword">else</span>:
        <span class="org-builtin">print</span>(f<span class="org-string">"HEAD detached at </span>{object_find(repo, 'HEAD')}<span class="org-string">"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-org45002f7" class="outline-4">
<h4 id="org45002f7"><span class="section-number-4">8.5.2.</span> Finding changes between HEAD and index</h4>
<div class="outline-text-4" id="text-8-5-2">
<p>
The second block of the status output is the “changes to be
committed”, that is, how the staging area differs from HEAD.  To do
this, we&rsquo;re going first to read the <code>HEAD</code> tree, and flatten it as a
single dict (hashmap) with full paths as keys, so it&rsquo;s closer to the
(flat) index associating paths to blobs.  Then we&rsquo;ll just compare
them and output their differences.
</p>

<p>
First, a function to convert a tree (recursive, remember) to a (flat)
dict.  And since trees are recursive, so the function itself is, again &#x2014;
sorry about that :)
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">tree_to_dict</span>(repo, ref, prefix<span class="org-operator">=</span><span class="org-string">""</span>):
    <span class="org-variable-name">ret</span> <span class="org-operator">=</span> <span class="org-builtin">dict</span>()
    <span class="org-variable-name">tree_sha</span> <span class="org-operator">=</span> object_find(repo, ref, fmt<span class="org-operator">=</span>b<span class="org-string">"tree"</span>)
    <span class="org-variable-name">tree</span> <span class="org-operator">=</span> object_read(repo, tree_sha)

    <span class="org-keyword">for</span> leaf <span class="org-keyword">in</span> tree.items:
        <span class="org-variable-name">full_path</span> <span class="org-operator">=</span> os.path.join(prefix, leaf.path)

        <span class="org-comment-delimiter"># </span><span class="org-comment">We read the object to extract its type (this is uselessly</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">expensive: we could just open it as a file and read the</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">first few bytes)</span>
        <span class="org-variable-name">is_subtree</span> <span class="org-operator">=</span> leaf.mode.startswith(b<span class="org-string">'04'</span>)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Depending on the type, we either store the path (if it's a</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">blob, so a regular file), or recurse (if it's another tree,</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">so a subdir)</span>
        <span class="org-keyword">if</span> is_subtree:
            ret.update(tree_to_dict(repo, leaf.sha, full_path))
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">ret</span>[full_path] <span class="org-operator">=</span> leaf.sha
    <span class="org-keyword">return</span> ret
</pre>
</div>

<p>
And the command itself:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cmd_status_head_index</span>(repo, index):
    <span class="org-builtin">print</span>(<span class="org-string">"Changes to be committed:"</span>)

    <span class="org-variable-name">head</span> <span class="org-operator">=</span> tree_to_dict(repo, <span class="org-string">"HEAD"</span>)
    <span class="org-keyword">for</span> entry <span class="org-keyword">in</span> index.entries:
        <span class="org-keyword">if</span> entry.name <span class="org-keyword">in</span> head:
            <span class="org-keyword">if</span> head[entry.name] <span class="org-operator">!=</span> entry.sha:
                <span class="org-builtin">print</span>(<span class="org-string">"  modified:"</span>, entry.name)
            <span class="org-keyword">del</span> head[entry.name] <span class="org-comment-delimiter"># </span><span class="org-comment">Delete the key</span>
        <span class="org-keyword">else</span>:
            <span class="org-builtin">print</span>(<span class="org-string">"  added:   "</span>, entry.name)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Keys still in HEAD are files that we haven't met in the index,</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">and thus have been deleted.</span>
    <span class="org-keyword">for</span> entry <span class="org-keyword">in</span> head.keys():
        <span class="org-builtin">print</span>(<span class="org-string">"  deleted: "</span>, entry)
</pre>
</div>
</div>
</div>
<div id="outline-container-org8b48b89" class="outline-4">
<h4 id="org8b48b89"><span class="section-number-4">8.5.3.</span> Finding changes between index and worktree</h4>
<div class="outline-text-4" id="text-8-5-3">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cmd_status_index_worktree</span>(repo, index):
    <span class="org-builtin">print</span>(<span class="org-string">"Changes not staged for commit:"</span>)

    <span class="org-variable-name">ignore</span> <span class="org-operator">=</span> gitignore_read(repo)

    <span class="org-variable-name">gitdir_prefix</span> <span class="org-operator">=</span> repo.gitdir <span class="org-operator">+</span> os.path.sep

    <span class="org-variable-name">all_files</span> <span class="org-operator">=</span> <span class="org-builtin">list</span>()

    <span class="org-comment-delimiter"># </span><span class="org-comment">We begin by walking the filesystem</span>
    <span class="org-keyword">for</span> (root, _, files) <span class="org-keyword">in</span> os.walk(repo.worktree, <span class="org-constant">True</span>):
        <span class="org-keyword">if</span> root<span class="org-operator">==</span>repo.gitdir <span class="org-keyword">or</span> root.startswith(gitdir_prefix):
            <span class="org-keyword">continue</span>
        <span class="org-keyword">for</span> f <span class="org-keyword">in</span> files:
            <span class="org-variable-name">full_path</span> <span class="org-operator">=</span> os.path.join(root, f)
            <span class="org-variable-name">rel_path</span> <span class="org-operator">=</span> os.path.relpath(full_path, repo.worktree)
            all_files.append(rel_path)

    <span class="org-comment-delimiter"># </span><span class="org-comment">We now traverse the index, and compare real files with the cached</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">versions.</span>

    <span class="org-keyword">for</span> entry <span class="org-keyword">in</span> index.entries:
        <span class="org-variable-name">full_path</span> <span class="org-operator">=</span> os.path.join(repo.worktree, entry.name)

        <span class="org-comment-delimiter"># </span><span class="org-comment">That file *name* is in the index</span>

        <span class="org-keyword">if</span> <span class="org-keyword">not</span> os.path.exists(full_path):
            <span class="org-builtin">print</span>(<span class="org-string">"  deleted: "</span>, entry.name)
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">stat</span> <span class="org-operator">=</span> os.stat(full_path)

            <span class="org-comment-delimiter"># </span><span class="org-comment">Compare metadata</span>
            <span class="org-variable-name">ctime_ns</span> <span class="org-operator">=</span> entry.ctime[0] <span class="org-operator">*</span> 10<span class="org-operator">**</span>9 <span class="org-operator">+</span> entry.ctime[1]
            <span class="org-variable-name">mtime_ns</span> <span class="org-operator">=</span> entry.mtime[0] <span class="org-operator">*</span> 10<span class="org-operator">**</span>9 <span class="org-operator">+</span> entry.mtime[1]
            <span class="org-keyword">if</span> (stat.st_ctime_ns <span class="org-operator">!=</span> ctime_ns) <span class="org-keyword">or</span> (stat.st_mtime_ns <span class="org-operator">!=</span> mtime_ns):
                <span class="org-comment-delimiter"># </span><span class="org-comment">If different, deep compare.</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">@FIXME This *will* crash on symlinks to dir.</span>
                <span class="org-keyword">with</span> <span class="org-builtin">open</span>(full_path, <span class="org-string">"rb"</span>) <span class="org-keyword">as</span> fd:
                    <span class="org-variable-name">new_sha</span> <span class="org-operator">=</span> object_hash(fd, b<span class="org-string">"blob"</span>, <span class="org-constant">None</span>)
                    <span class="org-comment-delimiter"># </span><span class="org-comment">If the hashes are the same, the files are actually the same.</span>
                    <span class="org-variable-name">same</span> <span class="org-operator">=</span> entry.sha <span class="org-operator">==</span> new_sha

                    <span class="org-keyword">if</span> <span class="org-keyword">not</span> same:
                        <span class="org-builtin">print</span>(<span class="org-string">"  modified:"</span>, entry.name)

        <span class="org-keyword">if</span> entry.name <span class="org-keyword">in</span> all_files:
            all_files.remove(entry.name)

    <span class="org-builtin">print</span>()
    <span class="org-builtin">print</span>(<span class="org-string">"Untracked files:"</span>)

    <span class="org-keyword">for</span> f <span class="org-keyword">in</span> all_files:
        <span class="org-comment-delimiter"># </span><span class="org-comment">@TODO If a full directory is untracked, we should display</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">its name without its contents.</span>
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> check_ignore(ignore, f):
            <span class="org-builtin">print</span>(<span class="org-string">" "</span>, f)
</pre>
</div>

<p>
Our status function is done.  It should output something like:
</p>

<pre class="example" id="org2784374">
$ wyag status
On branch main.
Changes to be committed:
  added:    src/main.c

Changes not staged for commit:
  modified: build.py
  deleted:  README.org

Untracked files:
  src/cli.c
</pre>

<p>
The real <code>status</code> is a lot smarter: it can detect renames, for
example, where ours cannot.  Another significant difference worth
mentioning is that <code>git status</code> actually <i>writes</i> the index back if a
file metadata was modified, but not its content.  You can see it with
our special ls-files:
</p>

<pre class="example" id="org8e1fbbc">
$ wyag ls-files --verbose
Index file format v2, containing 1 entries.
file
  regular file with perms: 644
  on blob: f2f279981ce01b095c42ee7162aadf60185c8f67
  created: 2023-07-18 18:26:15.771460869, modified: 2023-07-18 18:26:15.771460869
  ...
$ touch file
$ git status &gt; /dev/null
$ wyag ls-files --verbose
Index file format v2, containing 1 entries.
file
  regular file with perms: 644
  on blob: f2f279981ce01b095c42ee7162aadf60185c8f67
  created: 2023-07-18 18:26:41.421743098, modified: 2023-07-18 18:26:41.421743098
  ...
</pre>

<p>
Notice how both timestamps, from the <i>index file</i>, were updated by
<code>git status</code> to reflect the changes in the real file&rsquo;s metadata.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-committing" class="outline-2">
<h2 id="committing"><span class="section-number-2">9.</span> Staging area and index, part 2: staging and committing</h2>
<div class="outline-text-2" id="text-committing">
<p>
OK.  Let&rsquo;s create commits.
</p>

<p>
We have <i>almost</i> everything we need for that, except for three last
things:
</p>

<ol class="org-ol">
<li>We need commands to modify the index, so our commits aren&rsquo;t just a
copy of their parent.  Those commands are <code>add</code> and <code>rm</code>.</li>
<li>These commands need to write the modified index back, since we
commit <i>from the index</i>.</li>
<li>And obviously, we&rsquo;ll need the <code>commit</code> function and its associated
<code>wyag commit</code> command.</li>
</ol>
</div>
<div id="outline-container-index_write" class="outline-3">
<h3 id="index_write"><span class="section-number-3">9.1.</span> Writing the index</h3>
<div class="outline-text-3" id="text-index_write">
<p>
We&rsquo;ll start by writing the index.  Roughly, we&rsquo;re just serializing
everything back to binary.  This is a bit tedious, but the code should
be straightforward.  I&rsquo;m leaving the gory details for the comments,
but it&rsquo;s really just <code>index_read</code> in reverse &#x2014; refer to it if
needed, and the <code>GitIndexEntry</code> class.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">index_write</span>(repo, index):
    <span class="org-keyword">with</span> <span class="org-builtin">open</span>(repo_file(repo, <span class="org-string">"index"</span>), <span class="org-string">"wb"</span>) <span class="org-keyword">as</span> f:

        <span class="org-comment-delimiter"># </span><span class="org-comment">HEADER</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Write the magic bytes.</span>
        f.write(b<span class="org-string">"DIRC"</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Write version number.</span>
        f.write(index.version.to_bytes(4, <span class="org-string">"big"</span>))
        <span class="org-comment-delimiter"># </span><span class="org-comment">Write the number of entries.</span>
        f.write(<span class="org-builtin">len</span>(index.entries).to_bytes(4, <span class="org-string">"big"</span>))

        <span class="org-comment-delimiter"># </span><span class="org-comment">ENTRIES</span>

        <span class="org-variable-name">idx</span> <span class="org-operator">=</span> 0
        <span class="org-keyword">for</span> e <span class="org-keyword">in</span> index.entries:
            f.write(e.ctime[0].to_bytes(4, <span class="org-string">"big"</span>))
            f.write(e.ctime[1].to_bytes(4, <span class="org-string">"big"</span>))
            f.write(e.mtime[0].to_bytes(4, <span class="org-string">"big"</span>))
            f.write(e.mtime[1].to_bytes(4, <span class="org-string">"big"</span>))
            f.write(e.dev.to_bytes(4, <span class="org-string">"big"</span>))
            f.write(e.ino.to_bytes(4, <span class="org-string">"big"</span>))

            <span class="org-comment-delimiter"># </span><span class="org-comment">Mode</span>
            <span class="org-variable-name">mode</span> <span class="org-operator">=</span> (e.mode_type <span class="org-operator">&lt;&lt;</span> 12) <span class="org-operator">|</span> e.mode_perms
            f.write(mode.to_bytes(4, <span class="org-string">"big"</span>))

            f.write(e.uid.to_bytes(4, <span class="org-string">"big"</span>))
            f.write(e.gid.to_bytes(4, <span class="org-string">"big"</span>))

            f.write(e.fsize.to_bytes(4, <span class="org-string">"big"</span>))
            <span class="org-comment-delimiter"># </span><span class="org-comment">@FIXME Convert back to int.</span>
            f.write(<span class="org-builtin">int</span>(e.sha, 16).to_bytes(20, <span class="org-string">"big"</span>))

            <span class="org-variable-name">flag_assume_valid</span> <span class="org-operator">=</span> 0x1 <span class="org-operator">&lt;&lt;</span> 15 <span class="org-keyword">if</span> e.flag_assume_valid <span class="org-keyword">else</span> 0

            <span class="org-variable-name">name_bytes</span> <span class="org-operator">=</span> e.name.encode(<span class="org-string">"utf8"</span>)
            <span class="org-variable-name">bytes_len</span> <span class="org-operator">=</span> <span class="org-builtin">len</span>(name_bytes)
            <span class="org-keyword">if</span> bytes_len <span class="org-operator">&gt;=</span> 0xFFF:
                <span class="org-variable-name">name_length</span> <span class="org-operator">=</span> 0xFFF
            <span class="org-keyword">else</span>:
                <span class="org-variable-name">name_length</span> <span class="org-operator">=</span> bytes_len

            <span class="org-comment-delimiter"># </span><span class="org-comment">We merge back three pieces of data (two flags and the</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">length of the name) on the same two bytes.</span>
            f.write((flag_assume_valid <span class="org-operator">|</span> e.flag_stage <span class="org-operator">|</span> name_length).to_bytes(2, <span class="org-string">"big"</span>))

            <span class="org-comment-delimiter"># </span><span class="org-comment">Write back the name, and a final 0x00.</span>
            f.write(name_bytes)
            f.write((0).to_bytes(1, <span class="org-string">"big"</span>))

            <span class="org-variable-name">idx</span> <span class="org-operator">+=</span> 62 <span class="org-operator">+</span> <span class="org-builtin">len</span>(name_bytes) <span class="org-operator">+</span> 1

            <span class="org-comment-delimiter"># </span><span class="org-comment">Add padding if necessary.</span>
            <span class="org-keyword">if</span> idx <span class="org-operator">%</span> 8 <span class="org-operator">!=</span> 0:
                <span class="org-variable-name">pad</span> <span class="org-operator">=</span> 8 <span class="org-operator">-</span> (idx <span class="org-operator">%</span> 8)
                f.write((0).to_bytes(pad, <span class="org-string">"big"</span>))
                <span class="org-variable-name">idx</span> <span class="org-operator">+=</span> pad
</pre>
</div>
</div>
</div>
<div id="outline-container-cmd-rm" class="outline-3">
<h3 id="cmd-rm"><span class="section-number-3">9.2.</span> The rm command</h3>
<div class="outline-text-3" id="text-cmd-rm">
<p>
The easiest change we can do to an index is to remove an entry from
it, which mean that the next commit <b>won&rsquo;t include</b> this file.  This
is what the <code>git rm</code> command does.
</p>

<div class="danger" id="org97d157d">
<p>
<code>git rm</code> is <b>destructive</b>, and so is <code>wyag rm</code>.  The command not
only modifies the index, it also removes file(s) from the worktree.
Unlike git, <code>wyag rm</code> doesn&rsquo;t care if the file it removes isn&rsquo;t
saved.  Proceed with caution.
</p>

</div>

<p>
<code>rm</code> takes a single argument, a list of paths to remove:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argsp</span> <span class="org-operator">=</span> argsubparsers.add_parser(<span class="org-string">"rm"</span>, <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Remove files from the working tree and the index."</span>)
argsp.add_argument(<span class="org-string">"path"</span>, nargs<span class="org-operator">=</span><span class="org-string">"+"</span>, <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Files to remove"</span>)

<span class="org-keyword">def</span> <span class="org-function-name">cmd_rm</span>(args):
    <span class="org-variable-name">repo</span> <span class="org-operator">=</span> repo_find()
    rm(repo, args.path)
</pre>
</div>

<p>
The <code>rm</code> function is a bit long, but it&rsquo;s very simple.  It takes a
repository and a list of paths, reads that repository index, and
removes entries in the index that match this list.  The optional
arguments control whether the function should actually delete the
files, and whether it should abort if some paths aren&rsquo;t present on the
index (both those arguments are for the use of <code>add</code>, they&rsquo;re not
exposed in the <code>wyag rm</code> command).
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">rm</span>(repo, paths, delete<span class="org-operator">=</span><span class="org-constant">True</span>, skip_missing<span class="org-operator">=</span><span class="org-constant">False</span>):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Find and read the index</span>
    <span class="org-variable-name">index</span> <span class="org-operator">=</span> index_read(repo)

    <span class="org-variable-name">worktree</span> <span class="org-operator">=</span> repo.worktree <span class="org-operator">+</span> os.sep

    <span class="org-comment-delimiter"># </span><span class="org-comment">Make paths absolute</span>
    <span class="org-variable-name">abspaths</span> <span class="org-operator">=</span> <span class="org-builtin">set</span>()
    <span class="org-keyword">for</span> path <span class="org-keyword">in</span> paths:
        <span class="org-variable-name">abspath</span> <span class="org-operator">=</span> os.path.abspath(path)
        <span class="org-keyword">if</span> abspath.startswith(worktree):
            abspaths.add(abspath)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(f<span class="org-string">"Cannot remove paths outside of worktree: </span>{paths}<span class="org-string">"</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">The list of entries to *keep*, which we will write back to the</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">index.</span>
    <span class="org-variable-name">kept_entries</span> <span class="org-operator">=</span> <span class="org-builtin">list</span>()
    <span class="org-comment-delimiter"># </span><span class="org-comment">The list of removed paths, which we'll use after index update</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">to physically remove the actual paths from the filesystem.</span>
    <span class="org-variable-name">remove</span> <span class="org-operator">=</span> <span class="org-builtin">list</span>()

    <span class="org-comment-delimiter"># </span><span class="org-comment">Now iterate over the list of entries, and remove those whose</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">paths we find in abspaths.  Preserve the others in kept_entries.</span>
    <span class="org-keyword">for</span> e <span class="org-keyword">in</span> index.entries:
        <span class="org-variable-name">full_path</span> <span class="org-operator">=</span> os.path.join(repo.worktree, e.name)

        <span class="org-keyword">if</span> full_path <span class="org-keyword">in</span> abspaths:
            remove.append(full_path)
            abspaths.remove(full_path)
        <span class="org-keyword">else</span>:
            kept_entries.append(e) <span class="org-comment-delimiter"># </span><span class="org-comment">Preserve entry</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">If abspaths is empty, it means some paths weren't in the index.</span>
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(abspaths) <span class="org-operator">&gt;</span> 0 <span class="org-keyword">and</span> <span class="org-keyword">not</span> skip_missing:
        <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(f<span class="org-string">"Cannot remove paths not in the index: </span>{abspaths}<span class="org-string">"</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Physically delete paths from filesystem.</span>
    <span class="org-keyword">if</span> delete:
        <span class="org-keyword">for</span> path <span class="org-keyword">in</span> remove:
            os.unlink(path)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Update the list of entries in the index, and write it back.</span>
    index.<span class="org-variable-name">entries</span> <span class="org-operator">=</span> kept_entries
    index_write(repo, index)
</pre>
</div>

<p>
And we can now delete files with <code>wyag rm</code>.
</p>
</div>
</div>
<div id="outline-container-cmd-add" class="outline-3">
<h3 id="cmd-add"><span class="section-number-3">9.3.</span> The add command</h3>
<div class="outline-text-3" id="text-cmd-add">
<p>
Adding is just a bit more complex than removing, but nothing we don&rsquo;t
already know.  Staging a file to a three-steps operation:
</p>

<ol class="org-ol">
<li>We begin by removing the existing index entry, if there&rsquo;s one,
without removing the file itself (this is why the <code>rm</code> function we
just wrote has those optional arguments).</li>
<li>We then hash the file into a glob object,</li>
<li>create its entry,</li>
<li>And of course, finally write the modified index back.</li>
</ol>

<p>
First, the interface.  Nothing surprising, <code>wyag add PATH ...</code> where
PATH is one or more file(s) to stage.  The bridge is as boring as can be.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argsp</span> <span class="org-operator">=</span> argsubparsers.add_parser(<span class="org-string">"add"</span>, <span class="org-builtin">help</span> <span class="org-operator">=</span> <span class="org-string">"Add files contents to the index."</span>)
argsp.add_argument(<span class="org-string">"path"</span>, nargs<span class="org-operator">=</span><span class="org-string">"+"</span>, <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Files to add"</span>)

<span class="org-keyword">def</span> <span class="org-function-name">cmd_add</span>(args):
    <span class="org-variable-name">repo</span> <span class="org-operator">=</span> repo_find()
    add(repo, args.path)
</pre>
</div>

<p>
The main difference with <code>rm</code> is that <code>add</code> needs to create an index
entry.  This isn&rsquo;t hard: we just <code>stat()</code> the file and copy the
metadata in the index&rsquo;s field (<code>stat()</code> returns those metadata the
index stores: creation/modification time, and so on)
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">add</span>(repo, paths, delete<span class="org-operator">=</span><span class="org-constant">True</span>, skip_missing<span class="org-operator">=</span><span class="org-constant">False</span>):

    <span class="org-comment-delimiter"># </span><span class="org-comment">First remove all paths from the index, if they exist.</span>
    rm (repo, paths, delete<span class="org-operator">=</span><span class="org-constant">False</span>, skip_missing<span class="org-operator">=</span><span class="org-constant">True</span>)

    <span class="org-variable-name">worktree</span> <span class="org-operator">=</span> repo.worktree <span class="org-operator">+</span> os.sep

    <span class="org-comment-delimiter"># </span><span class="org-comment">Convert the paths to pairs: (absolute, relative_to_worktree).</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Also delete them from the index if they're present.</span>
    <span class="org-variable-name">clean_paths</span> <span class="org-operator">=</span> <span class="org-builtin">set</span>()
    <span class="org-keyword">for</span> path <span class="org-keyword">in</span> paths:
        <span class="org-variable-name">abspath</span> <span class="org-operator">=</span> os.path.abspath(path)
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> (abspath.startswith(worktree) <span class="org-keyword">and</span> os.path.isfile(abspath)):
            <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(f<span class="org-string">"Not a file, or outside the worktree: </span>{paths}<span class="org-string">"</span>)
        <span class="org-variable-name">relpath</span> <span class="org-operator">=</span> os.path.relpath(abspath, repo.worktree)
        clean_paths.add((abspath,  relpath))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Find and read the index.  It was modified by rm.  (This isn't</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">optimal, good enough for wyag!)</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">@FIXME, though: we could just move the index through</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">commands instead of reading and writing it over again.</span>
    <span class="org-variable-name">index</span> <span class="org-operator">=</span> index_read(repo)

    <span class="org-keyword">for</span> (abspath, relpath) <span class="org-keyword">in</span> clean_paths:
        <span class="org-keyword">with</span> <span class="org-builtin">open</span>(abspath, <span class="org-string">"rb"</span>) <span class="org-keyword">as</span> fd:
            <span class="org-variable-name">sha</span> <span class="org-operator">=</span> object_hash(fd, b<span class="org-string">"blob"</span>, repo)

            <span class="org-variable-name">stat</span> <span class="org-operator">=</span> os.stat(abspath)

            <span class="org-variable-name">ctime_s</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>(stat.st_ctime)
            <span class="org-variable-name">ctime_ns</span> <span class="org-operator">=</span> stat.st_ctime_ns <span class="org-operator">%</span> 10<span class="org-operator">**</span>9
            <span class="org-variable-name">mtime_s</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>(stat.st_mtime)
            <span class="org-variable-name">mtime_ns</span> <span class="org-operator">=</span> stat.st_mtime_ns <span class="org-operator">%</span> 10<span class="org-operator">**</span>9

            <span class="org-variable-name">entry</span> <span class="org-operator">=</span> GitIndexEntry(ctime<span class="org-operator">=</span>(ctime_s, ctime_ns), mtime<span class="org-operator">=</span>(mtime_s, mtime_ns), dev<span class="org-operator">=</span>stat.st_dev, ino<span class="org-operator">=</span>stat.st_ino,
                                  mode_type<span class="org-operator">=</span>0b1000, mode_perms<span class="org-operator">=</span>0o644, uid<span class="org-operator">=</span>stat.st_uid, gid<span class="org-operator">=</span>stat.st_gid,
                                  fsize<span class="org-operator">=</span>stat.st_size, sha<span class="org-operator">=</span>sha, flag_assume_valid<span class="org-operator">=</span><span class="org-constant">False</span>,
                                  flag_stage<span class="org-operator">=</span><span class="org-constant">False</span>, name<span class="org-operator">=</span>relpath)
            index.entries.append(entry)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Write the index back</span>
    index_write(repo, index)
</pre>
</div>
</div>
</div>
<div id="outline-container-cmd-commit" class="outline-3">
<h3 id="cmd-commit"><span class="section-number-3">9.4.</span> The commit command</h3>
<div class="outline-text-3" id="text-cmd-commit">
<p>
Now that we have modified the index, so actually <i>staged changes</i>, we
only need to turn those changes into a commit.  That&rsquo;s what <code>commit</code> does.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">argsp</span> <span class="org-operator">=</span> argsubparsers.add_parser(<span class="org-string">"commit"</span>, <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Record changes to the repository."</span>)

argsp.add_argument(<span class="org-string">"-m"</span>,
                   metavar<span class="org-operator">=</span><span class="org-string">"message"</span>,
                   dest<span class="org-operator">=</span><span class="org-string">"message"</span>,
                   <span class="org-builtin">help</span><span class="org-operator">=</span><span class="org-string">"Message to associate with this commit."</span>)
</pre>
</div>

<p>
To do so, we first need to convert the index into a tree object,
generate and store the corresponding commit object, and update the
HEAD branch to the new commit (remember: a branch is just a ref to a
commit).
</p>

<p>
Before we get to the interesting details, we will need to read git&rsquo;s
config to get the name of the user, which we&rsquo;ll use as the author and
committer.  We&rsquo;ll use the same <code>configparser</code> library we&rsquo;ve used to
read repo&rsquo;s config.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">gitconfig_read</span>():
    <span class="org-variable-name">xdg_config_home</span> <span class="org-operator">=</span> os.environ[<span class="org-string">"XDG_CONFIG_HOME"</span>] <span class="org-keyword">if</span> <span class="org-string">"XDG_CONFIG_HOME"</span> <span class="org-keyword">in</span> os.environ <span class="org-keyword">else</span> <span class="org-string">"~/.config"</span>
    <span class="org-variable-name">configfiles</span> <span class="org-operator">=</span> [
        os.path.expanduser(os.path.join(xdg_config_home, <span class="org-string">"git/config"</span>)),
        os.path.expanduser(<span class="org-string">"~/.gitconfig"</span>)
    ]

    <span class="org-variable-name">config</span> <span class="org-operator">=</span> configparser.ConfigParser()
    config.read(configfiles)
    <span class="org-keyword">return</span> config
</pre>
</div>

<p>
And just a simple function to grab, and format, the user identity:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">gitconfig_user_get</span>(config):
    <span class="org-keyword">if</span> <span class="org-string">"user"</span> <span class="org-keyword">in</span> config:
        <span class="org-keyword">if</span> <span class="org-string">"name"</span> <span class="org-keyword">in</span> config[<span class="org-string">"user"</span>] <span class="org-keyword">and</span> <span class="org-string">"email"</span> <span class="org-keyword">in</span> config[<span class="org-string">"user"</span>]:
            <span class="org-keyword">return</span> f<span class="org-string">"</span>{config['user']['name']}<span class="org-string"> &lt;</span>{config['user']['email']}<span class="org-string">&gt;"</span>
    <span class="org-keyword">return</span> <span class="org-constant">None</span>
</pre>
</div>

<p>
Now for the interesting part.  We first need to build a tree from the
index.  This isn&rsquo;t hard, but notice that while the index is flat (it
stores full paths for the whole worktree), a tree is a recursive
structure: it lists files, or other trees.  To &ldquo;unflatten&rdquo; the index
into a tree, we&rsquo;re going to:
</p>

<ol class="org-ol">
<li>Build a dictionary (hashmap) of directories.  Keys are full paths
from worktree root (like <code>assets/sprites/monsters/</code>), values are
list of <code>GitIndexEntry</code> &#x2014; files in the directory.  At this point, our
dictionary only contains <i>files</i>: directories are only its keys.</li>
<li>Traverse this list, going bottom-up, that is, from the deepest
directories up to root (depth doesn&rsquo;t really matter: we just want
to see each directory <i>before</i> its parent.  To do that, we just
sort them by <i>full</i> path length, from longest to shortest &#x2014;
parents are obviously always shorter).  As an example, imagine we
start at <code>assets/sprites/monsters/</code></li>
<li>At each directory, we build a tree with its contents, say
<code>cacodemon.png</code>, <code>imp.png</code> and <code>baron-of-hell.png</code>.</li>
<li>We write the new tree to the repository.</li>
<li>We then add this tree to this directory&rsquo;s parent.  Meaning that at
this point, <code>assets/sprites/</code> now contains our new tree object&rsquo;s
SHA-1 id under the name <code>monsters</code>.</li>
<li>And we iterate over the next directory, let&rsquo;s say
<code>assets/sprites/keys</code> where we find <code>red.png</code>, <code>blue.png</code> and
<code>yellow.png</code>, create a tree, store the tree, add the tree&rsquo;s SHA-1
under the name <code>keys</code> under <code>assets/sprites/</code>, and so on.</li>
</ol>

<p>
And since trees are recursive?  So the last tree we&rsquo;ll build, which is
necessarily the one for root (since its key&rsquo;s length is 0), will
ultimately refer to all others, and thus will be only one we&rsquo;ll need.
We&rsquo;ll simply return its SHA-1, and be done.
</p>

<p>
Since this may seem a bit complex, let&rsquo;s work this example in full
details &#x2014; feel free to skip.  At the beginning, the dictionary we
built from the index looks like this:
</p>

<pre class="example" id="org14e220c">
contents["assets/sprites/monsters"] =
  [ cacodemon.png : GitIndexEntry
  , imp.png : GitIndexEntry
  , baron-of-hell.png : GitIndexEntry ]
contents["assets/sprites/keys"] =
  [ red.png : GitIndexEntry
  , blue.png : GitIndexEntry
  , yellow.png : GitIndexEntry ]
contents["assets/sprites/"] =
  [ hero.png : GitIndexEntry ]
contents["assets/"] = [] # No files in here
contents[""] = # Root!
  [ README: GitIndexEntry ]
</pre>

<p>
We iterate over it, by order of descending key length.  The first key
we meet is the longest, so <code>assets/sprites/monsters</code>.  We build a new
tree object from its contents, which associates the three file names
(<code>cacodemon.png</code>, <code>imp.png</code>, <code>baron-of-hell.png</code>) with their
corresponding blobs (A tree leaf stores <i>less</i> data than the index &#x2014;
just path, mode and blob.  So converting entries that way is easy)
</p>

<p>
Notice we don&rsquo;t need to concern ourselves with storing the <b>contents</b>
of those files: <code>wyag add</code> did create the corresponding blobs as
needed.  We need to store the <i>trees</i> we create to the object store,
but we can assume the blobs are there already.
</p>

<p>
Let&rsquo;s say that our new tree hashes, made from the index entries that
lived directly in <code>assets/sprites/monsters</code>, hashes down to
<code>426f894781bc3c38f1d26f8fd2c7f38ab8d21763</code>.  We <b>modify our
dictionary</b> to add that new tree object to the directory&rsquo;s parent,
like this, so what remains to traverse now looks like this:
</p>

<pre class="example" id="org8a8825b">
contents["assets/sprites/keys"] = # &lt;- unmodified.
  [ red.png : GitIndexEntry
  , blue.png : GitIndexEntry
  , yellow.png : GitIndexEntry ]
contents["assets/sprites/"] =
  [ hero.png : GitIndexEntry
  , monsters : Tree 426f894781bc3c38f1d26f8fd2c7f38ab8d21763 ] &lt;- look here
contents["assets/"] = [] # empty
contents[""] = # Root!
  [ README: GitIndexEntry ]
</pre>

<p>
We do the same for the next longest key, <code>assets/sprites/keys</code>,
producing a tree of hash <code>b42788e087b1e94a0e69dcb7a4a243eaab802bb2</code>,
so:
</p>

<pre class="example" id="org5e0fc01">
contents["assets/sprites/"] =
  [ hero.png : GitIndexEntry
  ,  monsters : Tree 426f894781bc3c38f1d26f8fd2c7f38ab8d21763
  , keys : Tree b42788e087b1e94a0e69dcb7a4a243eaab802bb2 ]
contents["assets/"] = [] # empty
contents[""] = # Root!
  [ README: GitIndexEntry ]
</pre>

<p>
We then generate tree <code>6364113557ed681d775ccbd3c90895ed276956a2</code> from
assets/sprites, which now contains our two trees and <code>hero.png</code>.
</p>

<pre class="example" id="org29c61ed">
contents["assets/"] = [
  sprites: Tree 6364113557ed681d775ccbd3c90895ed276956a2 ]
contents[""] = # Root!
  [ README: GitIndexEntry ]
</pre>

<p>
Assets in turn becomes tree <code>4d35513cb6d2a816bc00505be926624440ebbddd</code>, so:
</p>

<pre class="example" id="orgac79a58">
contents[""] = # Root!
  [ README: GitIndexEntry,
    assets: 4d35513cb6d2a816bc00505be926624440ebbddd]
</pre>

<p>
We make a tree from that last key (with the <code>README</code> blob and the
<code>assets</code> subtree), it hashes to
<code>9352e52ff58fa9bf5a750f090af64c09fa6a3d93</code>.  That&rsquo;s our return value:
the tree whose contents are the same as the index&rsquo;s.
</p>

<p>
Here&rsquo;s the actual function:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">tree_from_index</span>(repo, index):
    <span class="org-variable-name">contents</span> <span class="org-operator">=</span> <span class="org-builtin">dict</span>()
    <span class="org-variable-name">contents</span>[<span class="org-string">""</span>] <span class="org-operator">=</span> <span class="org-builtin">list</span>()

    <span class="org-comment-delimiter"># </span><span class="org-comment">Enumerate entries, and turn them into a dictionary where keys</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">are directories, and values are lists of directory contents.</span>
    <span class="org-keyword">for</span> entry <span class="org-keyword">in</span> index.entries:
        <span class="org-variable-name">dirname</span> <span class="org-operator">=</span> os.path.dirname(entry.name)

        <span class="org-comment-delimiter"># </span><span class="org-comment">We create all dictonary entries up to root ("").  We need</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">them *all*, because even if a directory holds no files it</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">will contain at least a tree.</span>
        <span class="org-variable-name">key</span> <span class="org-operator">=</span> dirname
        <span class="org-keyword">while</span> key <span class="org-operator">!=</span> <span class="org-string">""</span>:
            <span class="org-keyword">if</span> <span class="org-keyword">not</span> key <span class="org-keyword">in</span> contents:
                <span class="org-variable-name">contents</span>[key] <span class="org-operator">=</span> <span class="org-builtin">list</span>()
            <span class="org-variable-name">key</span> <span class="org-operator">=</span> os.path.dirname(key)

        <span class="org-comment-delimiter"># </span><span class="org-comment">For now, simply store the entry in the list.</span>
        contents[dirname].append(entry)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Get keys (= directories) and sort them by length, descending.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">This means that we'll always encounter a given path before its</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">parent, which is all we need, since for each directory D we'll</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">need to modify its parent P to add D's tree.</span>
    <span class="org-variable-name">sorted_paths</span> <span class="org-operator">=</span> <span class="org-builtin">sorted</span>(contents.keys(), key<span class="org-operator">=</span><span class="org-builtin">len</span>, reverse<span class="org-operator">=</span><span class="org-constant">True</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">This variable will store the current tree's SHA-1.  After we're</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">done iterating over our dict, it will contain the hash for the</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">root tree.</span>
    <span class="org-variable-name">sha</span> <span class="org-operator">=</span> <span class="org-constant">None</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">We ge through the sorted list of paths (dict keys)</span>
    <span class="org-keyword">for</span> path <span class="org-keyword">in</span> sorted_paths:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Prepare a new, empty tree object</span>
        <span class="org-variable-name">tree</span> <span class="org-operator">=</span> GitTree()

        <span class="org-comment-delimiter"># </span><span class="org-comment">Add each entry to our new tree, in turn</span>
        <span class="org-keyword">for</span> entry <span class="org-keyword">in</span> contents[path]:
            <span class="org-comment-delimiter"># </span><span class="org-comment">An entry can be a normal GitIndexEntry read from the</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">index, or a tree we've created.</span>
            <span class="org-keyword">if</span> <span class="org-builtin">isinstance</span>(entry, GitIndexEntry): <span class="org-comment-delimiter"># </span><span class="org-comment">Regular entry (a file)</span>

                <span class="org-comment-delimiter"># </span><span class="org-comment">We transcode the mode: the entry stores it as integers,</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">we need an octal ASCII representation for the tree.</span>
                <span class="org-variable-name">leaf_mode</span> <span class="org-operator">=</span> f<span class="org-string">"</span>{entry.mode_type:02o}{entry.mode_perms:04o}<span class="org-string">"</span>.encode(<span class="org-string">"ascii"</span>)
                <span class="org-variable-name">leaf</span> <span class="org-operator">=</span> GitTreeLeaf(mode <span class="org-operator">=</span> leaf_mode, path<span class="org-operator">=</span>os.path.basename(entry.name), sha<span class="org-operator">=</span>entry.sha)
            <span class="org-keyword">else</span>: <span class="org-comment-delimiter"># </span><span class="org-comment">Tree.  We've stored it as a pair: (basename, SHA)</span>
                <span class="org-variable-name">leaf</span> <span class="org-operator">=</span> GitTreeLeaf(mode <span class="org-operator">=</span> b<span class="org-string">"040000"</span>, path<span class="org-operator">=</span>entry[0], sha<span class="org-operator">=</span>entry[1])

            tree.items.append(leaf)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Write the new tree object to the store.</span>
        <span class="org-variable-name">sha</span> <span class="org-operator">=</span> object_write(tree, repo)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Add the new tree hash to the current dictionary's parent, as</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">a pair (basename, SHA)</span>
        <span class="org-variable-name">parent</span> <span class="org-operator">=</span> os.path.dirname(path)
        <span class="org-variable-name">base</span> <span class="org-operator">=</span> os.path.basename(path) <span class="org-comment-delimiter"># </span><span class="org-comment">The name without the path, eg main.go for src/main.go</span>
        contents[parent].append((base, sha))

    <span class="org-keyword">return</span> sha
</pre>
</div>

<p>
This was the hard part; I hope it&rsquo;s clear enough.  From this, creating
the commit object and updating HEAD will be way easier.  Just remember
that what this function <i>does</i> is built and store as many tree objects
as needed to represent the index, and return the root tree&rsquo;s SHA-1.
</p>

<p>
The function to create a commit object is simple enough, it just takes
some arguments: the hash of the tree, the hash of the parent commit,
the author&rsquo;s identity (a string), the timestamp and timezone delta,
and the message:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">commit_create</span>(repo, tree, parent, author, timestamp, message):
    <span class="org-variable-name">commit</span> <span class="org-operator">=</span> GitCommit() <span class="org-comment-delimiter"># </span><span class="org-comment">Create the new commit object.</span>
    commit.<span class="org-variable-name">kvlm</span>[b<span class="org-string">"tree"</span>] <span class="org-operator">=</span> tree.encode(<span class="org-string">"ascii"</span>)
    <span class="org-keyword">if</span> parent:
        commit.<span class="org-variable-name">kvlm</span>[b<span class="org-string">"parent"</span>] <span class="org-operator">=</span> parent.encode(<span class="org-string">"ascii"</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Trim message and add a trailing \n</span>
    <span class="org-variable-name">message</span> <span class="org-operator">=</span> message.strip() <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Format timezone</span>
    <span class="org-variable-name">offset</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>(timestamp.astimezone().utcoffset().total_seconds())
    <span class="org-variable-name">hours</span> <span class="org-operator">=</span> offset <span class="org-operator">//</span> 3600
    <span class="org-variable-name">minutes</span> <span class="org-operator">=</span> (offset <span class="org-operator">%</span> 3600) <span class="org-operator">//</span> 60
    <span class="org-variable-name">tz</span> <span class="org-operator">=</span> <span class="org-string">"{}{:02}{:02}"</span>.<span class="org-builtin">format</span>(<span class="org-string">"+"</span> <span class="org-keyword">if</span> offset <span class="org-operator">&gt;</span> 0 <span class="org-keyword">else</span> <span class="org-string">"-"</span>, hours, minutes)

    <span class="org-variable-name">author</span> <span class="org-operator">=</span> author <span class="org-operator">+</span> timestamp.strftime(<span class="org-string">" %s "</span>) <span class="org-operator">+</span> tz

    commit.<span class="org-variable-name">kvlm</span>[b<span class="org-string">"author"</span>] <span class="org-operator">=</span> author.encode(<span class="org-string">"utf8"</span>)
    commit.<span class="org-variable-name">kvlm</span>[b<span class="org-string">"committer"</span>] <span class="org-operator">=</span> author.encode(<span class="org-string">"utf8"</span>)
    commit.<span class="org-variable-name">kvlm</span>[<span class="org-constant">None</span>] <span class="org-operator">=</span> message.encode(<span class="org-string">"utf8"</span>)

    <span class="org-keyword">return</span> object_write(commit, repo)
</pre>
</div>

<p>
All what remains to write is <code>cmd_commit</code>, the bridge function to the
<code>wyag commit</code> command:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cmd_commit</span>(args):
    <span class="org-variable-name">repo</span> <span class="org-operator">=</span> repo_find()
    <span class="org-variable-name">index</span> <span class="org-operator">=</span> index_read(repo)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Create trees, grab back SHA for the root tree.</span>
    <span class="org-variable-name">tree</span> <span class="org-operator">=</span> tree_from_index(repo, index)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Create the commit object itself</span>
    <span class="org-variable-name">commit</span> <span class="org-operator">=</span> commit_create(repo,
                           tree,
                           object_find(repo, <span class="org-string">"HEAD"</span>),
                           gitconfig_user_get(gitconfig_read()),
                           datetime.now(),
                           args.message)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Update HEAD so our commit is now the tip of the active branch.</span>
    <span class="org-variable-name">active_branch</span> <span class="org-operator">=</span> branch_get_active(repo)
    <span class="org-keyword">if</span> active_branch: <span class="org-comment-delimiter"># </span><span class="org-comment">If we're on a branch, we update refs/heads/BRANCH</span>
        <span class="org-keyword">with</span> <span class="org-builtin">open</span>(repo_file(repo, os.path.join(<span class="org-string">"refs/heads"</span>, active_branch)), <span class="org-string">"w"</span>) <span class="org-keyword">as</span> fd:
            fd.write(commit <span class="org-operator">+</span> <span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)
    <span class="org-keyword">else</span>: <span class="org-comment-delimiter"># </span><span class="org-comment">Otherwise, we update HEAD itself.</span>
        <span class="org-keyword">with</span> <span class="org-builtin">open</span>(repo_file(repo, <span class="org-string">"HEAD"</span>), <span class="org-string">"w"</span>) <span class="org-keyword">as</span> fd:
            fd.write(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">"</span>)
</pre>
</div>

<p>
And we&rsquo;re done!
</p>
</div>
</div>
</div>
<div id="outline-container-org6d635aa" class="outline-2">
<h2 id="org6d635aa"><span class="section-number-2">10.</span> Final words</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-feedback" class="outline-3">
<h3 id="feedback"><span class="section-number-3">10.1.</span> Comments, feedback and issues</h3>
<div class="outline-text-3" id="text-feedback">
<p>
This page has no comment system :) I can be reached by e-mail at
<a href="mailto:thibault@thb.lt">thibault@thb.lt</a>.  I can also be found <a href="https://toad.social/@thblt">on Mastodon as
@thblt@toad.social</a> and <a href="https://twitter.com/ThbPlg">on Twitter as @ThbPlg</a>, and on IRC (sometimes)
as <code>thblt</code> on Libera.
</p>

<p>
The source for this article is hosted <a href="https://github.com/thblt/write-yourself-a-git">on Github</a>.  Issue reports and
pull requests are welcome, either directly on GitHub or through e-mail
if you prefer.
</p>
</div>
</div>
<div id="outline-container-org4973c11" class="outline-3">
<h3 id="org4973c11"><span class="section-number-3">10.2.</span> License</h3>
<div class="outline-text-3" id="text-10-2">
<p>
This article is distributed under the terms of the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons
BY-NC-SA 4.0</a>.  The <a href="./wyag.zip">program itself</a> is also licensed under the terms
of the GNU General Public License 3.0, or, at your option, any later
version of the same licence.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
You may know that <a href="https://shattered.io/">collisions have been discovered in SHA-1</a>.
Git actually doesn&rsquo;t use SHA-1 anymore: it uses a <a href="https://github.com/git/git/blob/26e47e261e969491ad4e3b6c298450c061749c9e/Documentation/technical/hash-function-transition.txt#L34-L36">hardened variant</a>
which is not SHA, but which applies the same hash to every known input
but the two PDF files known to collide.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: <a href="mailto:thibault@thb.lt">Thibault Polge</a></p>
<p class="date">Created: 2025-05-05 lun. 17:37</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
